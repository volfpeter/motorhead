{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Source code: https://github.com/volfpeter/motorhead</p> <p>Documentation and examples: https://volfpeter.github.io/motorhead</p>"},{"location":"#motorhead","title":"Motorhead","text":"<p>Async MongoDB with vanilla Pydantic v2+ - made easy.</p> <p>Key features:</p> <ul> <li>Database model and API design with vanilla <code>Pydantic</code> v2+.</li> <li>Relationship support and validation using async validators and delete rules with a declarative, decorator-based syntax.</li> <li>ODM-like query builder for convenient, typed, and Pythonic query construction.</li> <li>Declarative index specification.</li> <li>Typed utilities for convenient model and API creation.</li> <li>Ready to use, customizable async service layer with transaction support that integrates all the above to keep your API and business logic clean, flexible, and easy to understand.</li> <li>Simplicity: by not being a classic ODM, the codebase is very simple and easy to understand (even contribute to) even for relative beginners.</li> </ul> <p>By providing a convenient, declarative middle layer between MongoDB and your API, <code>motorhead</code> is halfway between an object document mapper (based on vanilla <code>Pydantic</code>) and a database driver (by wrapping the official, async <code>motor</code> driver). What's missing is the built-in ODM performance and memory overhead, whose benefits are rarely felt when working with document databases.</p>"},{"location":"#installation","title":"Installation","text":"<p>The library is available on PyPI and can be installed with:</p> <pre><code>$ pip install motorhead\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>See the documentation for usage and application examples.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The project depends on <code>motor</code> (the official asyncio MongoDB driver, which is built on top of <code>pymongo</code> and <code>bson</code>) and <code>pydantic</code> v2+.</p>"},{"location":"#development","title":"Development","text":"<p>Use <code>black</code> for code formatting, <code>mypy</code> for static code analysis, <code>ruff</code> for linting, and <code>pytest</code> (with <code>pytest-asyncio</code> and <code>pytest-docker</code>) for testing.</p> <p>The documentation is built with <code>mkdocs-material</code> and <code>mkdocstrings</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions are welcome.</p>"},{"location":"#notes","title":"Notes","text":"<p>This project is the continuation of fastapi-motor-oil with support for Pydantic v2, among other improvements. Migration from <code>fastapi-motor-oil</code> should be easy, but if you need help, just create an issue in the issue tracker.</p>"},{"location":"#license-mit","title":"License - MIT","text":"<p>The library is open-sourced under the conditions of the MIT license.</p>"},{"location":"fastapi-example/","title":"FastAPI example","text":"<p>In this is example we will:</p> <ul> <li>create a simple <code>TreeNode</code> document model with a name, a creation date, and an optional reference to a parent node;</li> <li>prepare all the services that are necessary to create, read, update, or delete documents;</li> <li>declare a couple of delete rules and validators that enforce consistency;</li> <li>declare a unique name index for the <code>TreeNode</code> collection;</li> <li>implement a <code>fastapi</code> <code>APIRouter</code> factory that can be included in <code>fastapi</code> applications;</li> <li>set up the <code>fastapi</code> application itself;</li> <li>implement automatic index creation in the application's lifespan method.</li> </ul>"},{"location":"fastapi-example/#prerequisites","title":"Prerequisites","text":"<p>To follow and try this example, you will need:</p> <ul> <li>Python 3.10+;</li> <li>access to a MongoDB database (e.g. a Community Edition running locally);</li> <li><code>fastapi</code> (version <code>&gt;=0.100.1</code>) with all its dependencies (<code>pip install fastapi[all]</code>);</li> <li>and of course this library.</li> </ul>"},{"location":"fastapi-example/#project-layout","title":"Project layout","text":"<p>Create the root directory of your project, for example <code>tree-app</code>.</p> <p>Inside the root directory, create the root Python package for the application -- <code>tree_app</code> -- and add the following empty files to it:</p> <ul> <li><code>__init__.py</code></li> <li><code>api.py</code></li> <li><code>main.py</code></li> <li><code>model.py</code></li> <li><code>service.py</code></li> </ul> <p>In the end, your directory structure should look like this:</p> <ul> <li><code>tree-app</code> (root directory)</li> <ul> <li><code>tree_app</code> (root package)</li> <ul> <li><code>__init__.py</code></li> <li><code>api.py</code></li> <li><code>main.py</code></li> <li><code>model.py</code></li> <li><code>service.py</code></li> </ul> </ul> </ul>"},{"location":"fastapi-example/#model","title":"Model","text":"<p>First we will implement the data model in <code>model.py</code>. Actually, we will implement three (<code>pydantic</code>) model classes, one for document serialization, one for creation, and one for editing.</p> <p>Additionally we will create a <code>Queryable</code> class using the <code>Q</code> factory that we will be able to use later to construct queries in an ODM-like manner.</p> <pre><code>from motorhead import BaseDocument, Document, ObjectId, Q, UTCDatetime\nfrom pydantic import ConfigDict\n\n\nclass TreeNode(Document):\n    \"\"\"\n    Tree node document model.\n    \"\"\"\n\n    name: str\n    parent: ObjectId | None = None\n    created_at: UTCDatetime\n\n\nQTreeNode = Q(TreeNode)\n\"\"\"Queryable class for the `TreeNode` collection.\"\"\"\n\n\nclass TreeNodeCreate(BaseDocument):\n    \"\"\"\n    Tree node creation model.\n    \"\"\"\n\n    name: str\n    parent: ObjectId | None = None\n\n\nclass TreeNodeUpdate(BaseDocument):\n    \"\"\"\n    Tree node update model.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    name: str | None = None\n    parent: ObjectId | None = None\n</code></pre>"},{"location":"fastapi-example/#services","title":"Services","text":"<p>With the model in place, we can start working on the services (<code>service.py</code>) that we will use from the REST routes. This step is as simple as subclassing <code>Service</code> and specifying the collection name:</p> <pre><code>from collections.abc import Sequence\nfrom datetime import datetime, timezone\nfrom typing import Any, cast\n\nfrom bson import ObjectId\nfrom motor.core import AgnosticClientSession\nfrom motorhead import (\n    ClauseOrMongoQuery,\n    CollectionOptions,\n    Field,\n    IndexData,\n    Service,\n    delete_rule,\n    validator,\n)\n\nfrom .model import QTreeNode, TreeNodeCreate, TreeNodeUpdate\n\n\nclass TreeNodeService(Service[TreeNodeCreate, TreeNodeUpdate]):\n    \"\"\"\n    Tree node database services.\n    \"\"\"\n\n    __slots__ = ()\n\n    collection_name: str = \"tree_nodes\"\n\n    collection_options: CollectionOptions | None = None\n\n    async def _convert_for_insert(self, data: TreeNodeCreate) -&gt; dict[str, Any]:\n        return {\n            **(await super()._convert_for_insert(data)),\n            \"created_at\": datetime.now(timezone.utc),\n        }\n</code></pre> <p>Noticate that <code>TreeNodeCreate</code> does not have a <code>created_at</code> attribute. Instead we inject this attribute during creation by overriding the <code>_convert_for_insert()</code> method of the service.</p> <p>That could be it, but we want to enforce a level of consistency in the database. To do that, we will add a couple of delete rules and validators to the service.</p> <p>Note that the rules below do not fully enforce a tree structure, but they are good enough for demonstration purposes.</p> <pre><code>...\n\nclass TreeNodeService(Service[TreeNodeCreate, TreeNodeUpdate]):\n\n    ...\n\n    @delete_rule(\"pre\")  # Delete rule that removes the subtrees of deleted nodes.\n    async def dr_delete_subtree(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n        child_ids = await self.find_ids(cast(Field, QTreeNode.parent).In(ids), session=session)\n        if len(child_ids) &gt; 0:\n            # Recursion\n            await self.delete_many(cast(Field, QTreeNode.id).In(child_ids), options={\"session\": session})\n\n    @delete_rule(\"deny\")  # Delete rule that prevents the removal of root nodes.\n    async def dr_deny_if_root(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n        root_cnt = await self.count_documents(\n            cast(Field, QTreeNode.id).In(ids) &amp; (QTreeNode.parent == None),  # type: ignore[operator] # noqa [711]\n            options={\"session\": session},\n        )\n        if root_cnt &gt; 0:\n            raise ValueError(\"Can not delete root nodes.\")\n\n    @validator(\"insert-update\")\n    async def v_parent_valid(\n        self, data: TreeNodeCreate | TreeNodeUpdate, query: ClauseOrMongoQuery | None\n    ) -&gt; None:\n        if data.parent is None:  # No parent node is always fine\n            return\n\n        if not await self.exists(data.parent):  # Parent must exist.\n            raise ValueError(\"Parent does not exist.\")\n\n        if isinstance(data, TreeNodeCreate):  # No more checks during creation.\n            return\n\n        matched_ids = (await self.find_ids(query)) if isinstance(data, TreeNodeUpdate) else []\n        if data.parent in matched_ids:  # Self reference is forbidden.\n            raise ValueError(\"Self-reference.\")\n\n    ...\n</code></pre> <p>There are a couple of important things to notice in the code above:</p> <ul> <li>Validator methods can get either a MongoDB query <code>dict</code> or a <code>Clause</code> (any object with a <code>to_mongo()</code> method), that can be passed in to service methods for consumption.</li> <li>Instead of writing MongoDB query dicts, in delete rules we used the previously created <code>QTreeNode</code> queryable class to build queries in and ODM-like manner, e.g. <code>QTreeNode.id.In(ids) &amp; (QTreeNode.parent == None)</code>.</li> </ul> <p>Finally, we will declare the indexes of the collection by setting <code>TreeNodeService.indexes</code>, which must be an index name - <code>IndexData</code> dictionary. A unique, ascending, case-insensitive index on the <code>name</code> attribute can be declared like this:</p> <pre><code>...\n\nclass TreeNodeService(Service[TreeNodeCreate, TreeNodeUpdate]):\n    ...\n\n    indexes = {\n        \"unique-name\": IndexData(\n            keys=\"name\",\n            unique=True,\n            collation={\"locale\": \"en\", \"strength\": 1},\n        ),\n    }\n\n    ...\n</code></pre> <p>For all indexing options, please see the PyMongo documentation.</p> <p>Combining everything together, the final service implementation looks like this:</p> <pre><code>from collections.abc import Sequence\nfrom datetime import datetime, timezone\nfrom typing import Any, cast\n\nfrom bson import ObjectId\nfrom motor.core import AgnosticClientSession\nfrom motorhead import (\n    ClauseOrMongoQuery,\n    CollectionOptions,\n    Field,\n    IndexData,\n    Service,\n    delete_rule,\n    validator,\n)\n\nfrom .model import QTreeNode, TreeNodeCreate, TreeNodeUpdate\n\n\nclass TreeNodeService(Service[TreeNodeCreate, TreeNodeUpdate]):\n    \"\"\"\n    Tree node database services.\n    \"\"\"\n\n    __slots__ = ()\n\n    collection_name: str = \"tree_nodes\"\n\n    collection_options: CollectionOptions | None = None\n\n    indexes = {\n        \"unique-name\": IndexData(\n            keys=\"name\",\n            unique=True,\n            collation={\"locale\": \"en\", \"strength\": 1},\n        ),\n    }\n\n    @delete_rule(\"pre\")  # Delete rule that removes the subtrees of deleted nodes.\n    async def dr_delete_subtree(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n        child_ids = await self.find_ids(cast(Field, QTreeNode.parent).In(ids), session=session)\n        if len(child_ids) &gt; 0:\n            # Recursion\n            await self.delete_many(cast(Field, QTreeNode.id).In(child_ids), options={\"session\": session})\n\n    @delete_rule(\"deny\")  # Delete rule that prevents the removal of root nodes.\n    async def dr_deny_if_root(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n        root_cnt = await self.count_documents(\n            cast(Field, QTreeNode.id).In(ids) &amp; (QTreeNode.parent == None),  # type: ignore[operator] # noqa [711]\n            options={\"session\": session},\n        )\n        if root_cnt &gt; 0:\n            raise ValueError(\"Can not delete root nodes.\")\n\n    @validator(\"insert-update\")\n    async def v_parent_valid(\n        self, data: TreeNodeCreate | TreeNodeUpdate, query: ClauseOrMongoQuery | None\n    ) -&gt; None:\n        if data.parent is None:  # No parent node is always fine\n            return\n\n        if not await self.exists(data.parent):  # Parent must exist.\n            raise ValueError(\"Parent does not exist.\")\n\n        if isinstance(data, TreeNodeCreate):  # No more checks during creation.\n            return\n\n        matched_ids = (await self.find_ids(query)) if isinstance(data, TreeNodeUpdate) else []\n        if data.parent in matched_ids:  # Self reference is forbidden.\n            raise ValueError(\"Self-reference.\")\n\n    async def _convert_for_insert(self, data: TreeNodeCreate) -&gt; dict[str, Any]:\n        return {\n            **(await super()._convert_for_insert(data)),\n            \"created_at\": datetime.now(timezone.utc),\n        }\n</code></pre> <p>With the service implementation ready, we can move on to creating the REST API.</p>"},{"location":"fastapi-example/#routing","title":"Routing","text":"<p>In <code>api.py</code>, we will use the factory pattern to create an <code>APIRouter</code> instance for the <code>fastapi</code> application.</p> <p>Notice how we get access to the <code>TreeNodeService</code> instance in routes with annotated FastAPI dependencies, and how the database interactions are simple one-liners in all routes.</p> <pre><code>from typing import Annotated, Any\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom motorhead import AgnosticDatabase, DatabaseProvider, DeleteError, DeleteResultModel, ObjectId\n\nfrom .model import TreeNode, TreeNodeCreate, TreeNodeUpdate\nfrom .service import TreeNodeService\n\n\ndef make_api(\n    *,\n    get_database: DatabaseProvider,\n    prefix: str = \"/tree-node\",\n) -&gt; APIRouter:\n    \"\"\"\n    Tree node `APIRouter` factory.\n\n    Arguments:\n        get_database: FastAPI dependency that returns the `AgnosticDatabase`\n                      database instance for the API.\n        prefix: The prefix for the created `APIRouter`.\n\n    Returns:\n        The created `APIRouter` instance.\n    \"\"\"\n    DependsDatabase = Annotated[AgnosticDatabase, Depends(get_database)]\n\n    def get_service(database: DependsDatabase) -&gt; TreeNodeService:\n        return TreeNodeService(database)\n\n    DependsService = Annotated[TreeNodeService, Depends(get_service)]\n\n    api = APIRouter(prefix=prefix)\n\n    @api.get(\"/\", response_model=list[TreeNode])\n    async def get_all(service: DependsService) -&gt; list[dict[str, Any]]:\n        return [d async for d in service.find()]\n\n    @api.post(\"/\", response_model=TreeNode)\n    async def create(data: TreeNodeCreate, service: DependsService) -&gt; dict[str, Any]:\n        try:\n            return await service.create(data)\n        except Exception as e:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Creation failed.\") from e\n\n    @api.get(\"/{id}\", response_model=TreeNode)\n    async def get_by_id(id: ObjectId, service: DependsService) -&gt; dict[str, Any]:\n        if (result := await service.get_by_id(id)) is not None:\n            return result\n\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(id))\n\n    @api.put(\"/{id}\", response_model=TreeNode)\n    async def update_by_id(id: ObjectId, data: TreeNodeUpdate, service: DependsService) -&gt; dict[str, Any]:\n        try:\n            return await service.update(id, data)\n        except Exception as e:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(id)) from e\n\n    @api.delete(\"/{id}\", response_model=DeleteResultModel)\n    async def delete_by_id(id: ObjectId, service: DependsService) -&gt; DeleteResultModel:\n        try:\n            result = await service.delete_by_id(id)\n        except DeleteError as e:\n            raise HTTPException(status.HTTP_400_BAD_REQUEST, detail=str(id)) from e\n        if result.deleted_count == 0:\n            raise HTTPException(status.HTTP_404_NOT_FOUND, detail=str(id))\n\n        return DeleteResultModel(delete_count=result.deleted_count)\n\n    return api\n</code></pre>"},{"location":"fastapi-example/#the-application","title":"The application","text":"<p>Finally, we can create the application itself and include our routes in it:</p> <pre><code>from collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom functools import lru_cache\n\nfrom fastapi import FastAPI\nfrom motor.core import AgnosticClient, AgnosticDatabase\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\n\n@lru_cache(maxsize=1)\ndef get_database() -&gt; AgnosticDatabase:\n    \"\"\"Database provider dependency for the created API.\"\"\"\n    mongo_connection_string = \"mongodb://127.0.0.1:27017\"\n    database_name = \"tree-db\"\n    client: AgnosticClient = AsyncIOMotorClient(mongo_connection_string)\n    return client[database_name]\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncGenerator[None, None]:\n    # Create all indexes on startup if they don't exist already.\n    from .service import TreeNodeService\n\n    db = get_database()\n\n    await TreeNodeService(db).create_indexes()\n\n    yield  # Application starts\n\n\ndef register_routes(app: FastAPI) -&gt; None:\n    \"\"\"Registers all routes of the application.\"\"\"\n    from .api import make_api as make_tree_node_api\n\n    api_prefix = \"/api/v1\"\n\n    app.include_router(\n        make_tree_node_api(get_database=get_database),\n        prefix=api_prefix,\n    )\n\n\ndef create_app() -&gt; FastAPI:\n    app = FastAPI(lifespan=lifespan)  # Set lifespan method.\n\n    register_routes(app)\n\n    return app\n</code></pre> <p>Notice the async <code>lifespan()</code> method (context manager) that creates the declared indexes before the application starts serving requests by calling the <code>create_indexes()</code> method of each service. There are of course many other ways for adding index creation (or recreation) to an application, like database migration or command line tools. Doing it in the <code>lifespan</code> method of the application is just one, easy to implement solution that works well for relatively small databases and for this demo application.</p>"},{"location":"fastapi-example/#starting-the-application","title":"Starting the application","text":"<p>With everything ready, we can start the application by executing <code>uvicorn tree_app.main:create_app --reload --factory</code> in the root directory and go to http://127.0.0.1:8000/docs to try the created REST API.</p>"},{"location":"api/aggregation/","title":"Aggregation","text":""},{"location":"api/aggregation/#motorhead.aggregation","title":"<code>motorhead.aggregation</code>","text":""},{"location":"api/aggregation/#motorhead.aggregation.AggregationStage","title":"<code>AggregationStage = Literal['$addFields', '$bucket', '$bucketAuto', '$changeStream', '$changeStreamSplitLargeEvent', '$collStats', '$count', '$currentOp', '$densify', '$documents', '$facet', '$fill', '$geoNear', '$graphLookup', '$group', '$indexStats', '$limit', '$listLocalSessions', '$listSampledQueries', '$listSearchIndexes', '$listSessions', '$lookup', '$match', '$merge', '$out', '$planCacheStats', '$project', '$querySettings', '$redact', '$replaceRoot', '$replaceWith', '$sample', '$search', '$searchMeta', '$set', '$setWindowFields', '$shardedDataDistribution', '$skip', '$sort', '$sortByCount', '$unionWith', '$unset', '$unwind', '$vectorSearch']</code>  <code>module-attribute</code>","text":"<p>Aggregation pipeline stage.</p>"},{"location":"api/aggregation/#motorhead.aggregation.Aggregation","title":"<code>Aggregation</code>","text":"<p>               Bases: <code>list[dict[str, AggregationData]]</code></p> <p>Aggregation pipeline.</p> Source code in <code>motorhead/aggregation.py</code> <pre><code>class Aggregation(list[dict[str, AggregationData]]):\n    \"\"\"Aggregation pipeline.\"\"\"\n\n    def __init__(self, stages: Iterable[AggregationData] = ()) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            stages: The aggregation pipeline stages.\n        \"\"\"\n        super().__init__(stages)\n\n    def stage(self, stage: AggregationStage, value: AggregationData | Clause) -&gt; Self:\n        \"\"\"\n        Adds the stage to the aggregation pipeline.\n\n        Arguments:\n            stage: The stage operator.\n            value: The stage operator's content.\n\n        Returns:\n            The aggregation pipeline.\n        \"\"\"\n        self.append(make_aggregation_stage(stage, value))\n        return self\n</code></pre>"},{"location":"api/aggregation/#motorhead.aggregation.Aggregation.__init__","title":"<code>__init__(stages=())</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>stages</code> <code>Iterable[AggregationData]</code> <p>The aggregation pipeline stages.</p> <code>()</code> Source code in <code>motorhead/aggregation.py</code> <pre><code>def __init__(self, stages: Iterable[AggregationData] = ()) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        stages: The aggregation pipeline stages.\n    \"\"\"\n    super().__init__(stages)\n</code></pre>"},{"location":"api/aggregation/#motorhead.aggregation.Aggregation.stage","title":"<code>stage(stage, value)</code>","text":"<p>Adds the stage to the aggregation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>AggregationStage</code> <p>The stage operator.</p> required <code>value</code> <code>AggregationData | Clause</code> <p>The stage operator's content.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The aggregation pipeline.</p> Source code in <code>motorhead/aggregation.py</code> <pre><code>def stage(self, stage: AggregationStage, value: AggregationData | Clause) -&gt; Self:\n    \"\"\"\n    Adds the stage to the aggregation pipeline.\n\n    Arguments:\n        stage: The stage operator.\n        value: The stage operator's content.\n\n    Returns:\n        The aggregation pipeline.\n    \"\"\"\n    self.append(make_aggregation_stage(stage, value))\n    return self\n</code></pre>"},{"location":"api/aggregation/#motorhead.aggregation.make_aggregation_stage","title":"<code>make_aggregation_stage(stage, value)</code>","text":"<p>Creates an aggregation pipeline stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>AggregationStage</code> <p>The stage operator.</p> required <code>value</code> <code>AggregationData | Clause</code> <p>The stage operator's content.</p> required <p>Returns:</p> Type Description <code>dict[str, AggregationData]</code> <p>The aggregation pipeline stage.</p> Source code in <code>motorhead/aggregation.py</code> <pre><code>def make_aggregation_stage(\n    stage: AggregationStage, value: AggregationData | Clause\n) -&gt; dict[str, AggregationData]:\n    \"\"\"\n    Creates an aggregation pipeline stage.\n\n    Arguments:\n        stage: The stage operator.\n        value: The stage operator's content.\n\n    Returns:\n        The aggregation pipeline stage.\n    \"\"\"\n    return {stage: value.to_mongo() if hasattr(value, \"to_mongo\") else value}\n</code></pre>"},{"location":"api/bound-method-wrapper/","title":"Bound method wrapper","text":""},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper","title":"<code>motorhead.bound_method_wrapper</code>","text":""},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper","title":"<code>BoundMethodWrapper</code>","text":"<p>               Bases: <code>Generic[TOwner, TParams, TConfig]</code></p> <p>Async method wrapper that also acts as a bound instance method when it replaces an instance method of a class.</p> <p>Note: the wrapped method will be unbound.</p> Caveats <p>This class acts as if it was a bound method of the instance using the descriptor protocol, but of course it is not a bound method, which becomes important when trying to apply decorators on the wrapper instance. In those cases the wrapper acts as a static method whose first argument is the instance, so you need to apply decorators that match this signature.</p> Configuration <p>exception: An optional exception factory (or type) that accepts a single string            argument and returns an exception. If not <code>None</code>, then exceptions            raised by the wrapped method will be caught and replaced by the exception            this method produces.</p> Source code in <code>motorhead/bound_method_wrapper.py</code> <pre><code>class BoundMethodWrapper(Generic[TOwner, TParams, TConfig]):\n    \"\"\"\n    Async method wrapper that also acts as a bound instance method when it replaces\n    an instance method of a class.\n\n    Note: the wrapped method will be unbound.\n\n    Caveats:\n        This class acts as if it was a bound method of the instance using the\n        descriptor protocol, but of course it is not a bound method, which becomes\n        important when trying to apply decorators on the wrapper instance. In those\n        cases the wrapper acts as a static method whose first argument is the instance,\n        so you need to apply decorators that match this signature.\n\n    Configuration:\n        exception: An optional exception factory (or type) that accepts a single string\n                   argument and returns an exception. If not `None`, then exceptions\n                   raised by the wrapped method will be caught and replaced by the exception\n                   this method produces.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_wrapped\", \"_exec\", \"_owner\")\n\n    exception: Callable[[str], Exception] | None = None\n\n    def __init__(\n        self,\n        wrapped: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]],\n        config: TConfig,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            wrapped: The wrapped method.\n            config: Wrapper configuration.\n        \"\"\"\n        self._config = config\n        self._wrapped = wrapped\n        self._exec: Callable[TParams, Coroutine[None, None, None]] | None = None\n        self._owner: TOwner | None = None\n\n    @property\n    def config(self) -&gt; TConfig:\n        \"\"\"\n        Wrapper configuration.\n        \"\"\"\n        return self._config\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        The (qualified) name of the wrapped method.\n        \"\"\"\n        return self._wrapped.__qualname__\n\n    def __get__(\n        self, owner: TOwner, obj_type: type[TOwner] | None = None\n    ) -&gt; Callable[TParams, Coroutine[None, None, None]]:\n        \"\"\"\n        Descriptor implementation that makes the wrapper work as a bound method of its owner.\n        \"\"\"\n        if owner is self._owner and self._exec is not None:\n            return self._exec\n\n        async def exec(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n            return await self(owner, *args, **kwargs)\n\n        self._exec = exec\n        self._owner = owner\n\n        return exec\n\n    async def __call__(self, owner: TOwner, *args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n        \"\"\"\n        Executes the wrapped *unbound* method with the given `owner`.\n\n        Exceptions raised by the wrapped method will be transformed by the `exception` attribute.\n\n        Arguments:\n            owner: The owner instance of the wrapper (the `self` argument of the wrapped instance method).\n            *args: The wrapped method's positional arguments.\n            *kwargs: The wrapped method's keyword arguments.\n        \"\"\"\n        try:\n            await self._wrapped(owner, *args, **kwargs)\n        except Exception as e:\n            raise e if self.exception is None else self.exception(f\"Method failed: {self.name}\") from e\n</code></pre>"},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper.config","title":"<code>config</code>  <code>property</code>","text":"<p>Wrapper configuration.</p>"},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper.name","title":"<code>name</code>  <code>property</code>","text":"<p>The (qualified) name of the wrapped method.</p>"},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper.__call__","title":"<code>__call__(owner, *args, **kwargs)</code>  <code>async</code>","text":"<p>Executes the wrapped unbound method with the given <code>owner</code>.</p> <p>Exceptions raised by the wrapped method will be transformed by the <code>exception</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>TOwner</code> <p>The owner instance of the wrapper (the <code>self</code> argument of the wrapped instance method).</p> required <code>*args</code> <code>args</code> <p>The wrapped method's positional arguments.</p> <code>()</code> <code>*kwargs</code> <code>kwargs</code> <p>The wrapped method's keyword arguments.</p> <code>{}</code> Source code in <code>motorhead/bound_method_wrapper.py</code> <pre><code>async def __call__(self, owner: TOwner, *args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n    \"\"\"\n    Executes the wrapped *unbound* method with the given `owner`.\n\n    Exceptions raised by the wrapped method will be transformed by the `exception` attribute.\n\n    Arguments:\n        owner: The owner instance of the wrapper (the `self` argument of the wrapped instance method).\n        *args: The wrapped method's positional arguments.\n        *kwargs: The wrapped method's keyword arguments.\n    \"\"\"\n    try:\n        await self._wrapped(owner, *args, **kwargs)\n    except Exception as e:\n        raise e if self.exception is None else self.exception(f\"Method failed: {self.name}\") from e\n</code></pre>"},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper.__get__","title":"<code>__get__(owner, obj_type=None)</code>","text":"<p>Descriptor implementation that makes the wrapper work as a bound method of its owner.</p> Source code in <code>motorhead/bound_method_wrapper.py</code> <pre><code>def __get__(\n    self, owner: TOwner, obj_type: type[TOwner] | None = None\n) -&gt; Callable[TParams, Coroutine[None, None, None]]:\n    \"\"\"\n    Descriptor implementation that makes the wrapper work as a bound method of its owner.\n    \"\"\"\n    if owner is self._owner and self._exec is not None:\n        return self._exec\n\n    async def exec(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n        return await self(owner, *args, **kwargs)\n\n    self._exec = exec\n    self._owner = owner\n\n    return exec\n</code></pre>"},{"location":"api/bound-method-wrapper/#motorhead.bound_method_wrapper.BoundMethodWrapper.__init__","title":"<code>__init__(wrapped, config)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped</code> <code>Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]]</code> <p>The wrapped method.</p> required <code>config</code> <code>TConfig</code> <p>Wrapper configuration.</p> required Source code in <code>motorhead/bound_method_wrapper.py</code> <pre><code>def __init__(\n    self,\n    wrapped: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]],\n    config: TConfig,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        wrapped: The wrapped method.\n        config: Wrapper configuration.\n    \"\"\"\n    self._config = config\n    self._wrapped = wrapped\n    self._exec: Callable[TParams, Coroutine[None, None, None]] | None = None\n    self._owner: TOwner | None = None\n</code></pre>"},{"location":"api/delete-rule/","title":"Delete rule","text":""},{"location":"api/delete-rule/#motorhead.delete_rule","title":"<code>motorhead.delete_rule</code>","text":""},{"location":"api/delete-rule/#motorhead.delete_rule.DeleteConfig","title":"<code>DeleteConfig = Literal['deny', 'pre', 'post']</code>  <code>module-attribute</code>","text":"<p>Delete rule configuration that specifies when a given delete rule must be executed.</p>"},{"location":"api/delete-rule/#motorhead.delete_rule.DeleteRule","title":"<code>DeleteRule</code>","text":"<p>               Bases: <code>BoundMethodWrapper[TOwner, [AgnosticClientSession, Sequence[TPrimaryKey]], DeleteConfig]</code></p> <p>Delete rule wrapper.</p> <p>Delete rules receive an <code>AgnosticClientSession</code> instance and a list of document IDs, and implement any deny, pre- or post-delete behavior.</p> <p>Delete rule execution sequence:</p> <ul> <li>\"deny\" rules are executed first - delete rules whose role is to prevent   a delete operation should have this config.</li> <li>\"pre\" rules are executed next.</li> <li>Then the requested delete operation takes place.</li> <li>Finally the \"post\" delete rules are executed.</li> </ul> <p>Delete rules are always called in a transaction. Well-behaved delete rules must:</p> <ul> <li>always use the received session instance to interact with the database,   i.e. forward the received session to every database driver call;</li> <li>not commit the session;</li> <li>not start a new transaction (see <code>session.in_transaction</code>);</li> <li>raise an exception if the operation can or must not complete.</li> </ul> <p>Example:</p> <pre><code>class SVC(Service):\n    @delete_rule(\"pre\")\n    async def delete_cascade(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n        from x.y.z import OtherService\n\n        other_service = OtherService(self._database)\n        await other_service.delete_many({\"foo_ref\": {\"$in\": ids}}, options={\"session\": session})\n</code></pre> Source code in <code>motorhead/delete_rule.py</code> <pre><code>class DeleteRule(BoundMethodWrapper[TOwner, [AgnosticClientSession, Sequence[TPrimaryKey]], DeleteConfig]):\n    \"\"\"\n    Delete rule wrapper.\n\n    Delete rules receive an `AgnosticClientSession` instance and a list of document IDs,\n    and implement any deny, pre- or post-delete behavior.\n\n    Delete rule execution sequence:\n\n    - \"deny\" rules are executed first - delete rules whose role is to prevent\n      a delete operation should have this config.\n    - \"pre\" rules are executed next.\n    - Then the requested delete operation takes place.\n    - Finally the \"post\" delete rules are executed.\n\n    Delete rules are always called in a transaction. Well-behaved delete rules must:\n\n    - always use the received session instance to interact with the database,\n      i.e. forward the received session to every database driver call;\n    - *not* commit the session;\n    - *not* start a new transaction (see `session.in_transaction`);\n    - raise an exception if the operation can or must not complete.\n\n    Example:\n\n    ```python\n    class SVC(Service):\n        @delete_rule(\"pre\")\n        async def delete_cascade(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n            from x.y.z import OtherService\n\n            other_service = OtherService(self._database)\n            await other_service.delete_many({\"foo_ref\": {\"$in\": ids}}, options={\"session\": session})\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    exception = DeleteError\n</code></pre>"},{"location":"api/delete-rule/#motorhead.delete_rule.delete_rule","title":"<code>delete_rule(config='pre')</code>","text":"<p>Decorator that converts a <code>Service</code> method into a <code>DeleteRule</code> that is then automatically applied by the service during delete operations.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeleteConfig</code> <p>Delete rule configuration.</p> <code>'pre'</code> Source code in <code>motorhead/delete_rule.py</code> <pre><code>def delete_rule(\n    config: DeleteConfig = \"pre\",\n) -&gt; Callable[\n    [Callable[[TOwner, AgnosticClientSession, Sequence[TPrimaryKey]], Coroutine[None, None, None]]],\n    \"DeleteRule[TOwner, TPrimaryKey]\",\n]:\n    \"\"\"\n    Decorator that converts a `Service` method into a `DeleteRule` that is then\n    automatically applied by the service during delete operations.\n\n    Arguments:\n        config: Delete rule configuration.\n    \"\"\"\n\n    def decorator(\n        func: Callable[[TOwner, AgnosticClientSession, Sequence[TPrimaryKey]], Coroutine[None, None, None]],\n        /,\n    ) -&gt; \"DeleteRule[TOwner, TPrimaryKey]\":\n        return DeleteRule(wrapped=func, config=config)\n\n    return decorator\n</code></pre>"},{"location":"api/operator/","title":"Operator","text":""},{"location":"api/operator/#motorhead.operator","title":"<code>motorhead.operator</code>","text":""},{"location":"api/operator/#motorhead.operator.All","title":"<code>All</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$all</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class All(KeyValueOperator):\n    \"\"\"`$all` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, key: str | Field, value: list[Any]) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, list):\n            raise ValueError(\"All field only accepts list values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.All.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>list[Any]</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: list[Any]) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, list):\n        raise ValueError(\"All field only accepts list values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.And","title":"<code>And</code>","text":"<p>               Bases: <code>ClauseOperator</code></p> <p><code>$and</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class And(ClauseOperator):\n    \"\"\"`$and` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ClauseOperator","title":"<code>ClauseOperator</code>","text":"<p>Base class for clause sequence based operators.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class ClauseOperator:\n    \"\"\"Base class for clause sequence based operators.\"\"\"\n\n    __slots__ = (\"_clauses\",)\n\n    _operator: str = None  # type: ignore[assignment]\n\n    def __init__(self, *clauses: Clause) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *clauses: The operator's clauses.\n        \"\"\"\n        self._clauses = clauses\n\n    def __init_subclass__(cls) -&gt; None:\n        if cls._operator is None:\n            cls._operator = f\"${cls.__name__.lower()}\"\n\n    @property\n    def clauses(self) -&gt; Generator[Clause, None, None]:\n        \"\"\"Generator that yields the operator's clauses.\"\"\"\n        for clause in self._clauses:\n            yield clause\n\n    def to_mongo(self) -&gt; dict[str, Any]:\n        \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n        return {self._operator: [c.to_mongo() for c in self._clauses]}\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ClauseOperator.clauses","title":"<code>clauses</code>  <code>property</code>","text":"<p>Generator that yields the operator's clauses.</p>"},{"location":"api/operator/#motorhead.operator.ClauseOperator.__init__","title":"<code>__init__(*clauses)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*clauses</code> <code>Clause</code> <p>The operator's clauses.</p> <code>()</code> Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, *clauses: Clause) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *clauses: The operator's clauses.\n    \"\"\"\n    self._clauses = clauses\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ClauseOperator.to_mongo","title":"<code>to_mongo()</code>","text":"<p>Converts the operator to a MongoDB-compatible dict.</p> Source code in <code>motorhead/operator.py</code> <pre><code>def to_mongo(self) -&gt; dict[str, Any]:\n    \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n    return {self._operator: [c.to_mongo() for c in self._clauses]}\n</code></pre>"},{"location":"api/operator/#motorhead.operator.DirectEq","title":"<code>DirectEq</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p>Plain equality operator, <code>{key: value}</code>.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class DirectEq(KeyValueOperator):\n    \"\"\"Plain equality operator, `{key: value}`.\"\"\"\n\n    __slots__ = ()\n    _operator = \"\"\n\n    def to_mongo(self) -&gt; dict[str, Any]:\n        return {self._key: self._value}\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ElemMatch","title":"<code>ElemMatch</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$elemMatch</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class ElemMatch(KeyValueOperator):\n    \"\"\"`$elemMatch` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n    _operator = \"$elemMatch\"\n\n    def __init__(self, key: str | Field, value: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, dict):\n            raise ValueError(\"ElemMatch field only accepts dict values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ElemMatch.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>dict[str, Any]</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, dict):\n        raise ValueError(\"ElemMatch field only accepts dict values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Eq","title":"<code>Eq</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$eq</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Eq(KeyValueOperator):\n    \"\"\"`$eq` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Exists","title":"<code>Exists</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$exists</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Exists(KeyValueOperator):\n    \"\"\"`$exists` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, key: str | Field, value: bool) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise ValueError(\"Exists field only accepts bool values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Exists.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>bool</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: bool) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, bool):\n        raise ValueError(\"Exists field only accepts bool values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Gt","title":"<code>Gt</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$gt</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Gt(KeyValueOperator):\n    \"\"\"`$gt` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Gte","title":"<code>Gte</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$gte</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Gte(KeyValueOperator):\n    \"\"\"`$gte` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.In","title":"<code>In</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$in</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class In(KeyValueOperator):\n    \"\"\"`$in` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.KeyValueOperator","title":"<code>KeyValueOperator</code>","text":"<p>Base class for key-value pair based operators.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class KeyValueOperator:\n    \"\"\"Base class for key-value pair based operators.\"\"\"\n\n    __slots__ = (\"_key\", \"_value\")\n\n    _operator: str = None  # type: ignore[assignment]\n\n    def __init__(self, key: str | Field, value: Any) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        self._key = key if isinstance(key, str) else key.name\n        self._value = value\n\n    def __init_subclass__(cls) -&gt; None:\n        if cls._operator is None:\n            cls._operator = f\"${cls.__name__.lower()}\"\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"The operator's key (the document attribute name).\"\"\"\n        return self._key\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"The operator's value.\"\"\"\n        return self._value\n\n    def to_mongo(self) -&gt; dict[str, Any]:\n        \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n        return {self._key: {self._operator: self._value}}\n</code></pre>"},{"location":"api/operator/#motorhead.operator.KeyValueOperator.key","title":"<code>key</code>  <code>property</code>","text":"<p>The operator's key (the document attribute name).</p>"},{"location":"api/operator/#motorhead.operator.KeyValueOperator.value","title":"<code>value</code>  <code>property</code>","text":"<p>The operator's value.</p>"},{"location":"api/operator/#motorhead.operator.KeyValueOperator.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>Any</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: Any) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    self._key = key if isinstance(key, str) else key.name\n    self._value = value\n</code></pre>"},{"location":"api/operator/#motorhead.operator.KeyValueOperator.to_mongo","title":"<code>to_mongo()</code>","text":"<p>Converts the operator to a MongoDB-compatible dict.</p> Source code in <code>motorhead/operator.py</code> <pre><code>def to_mongo(self) -&gt; dict[str, Any]:\n    \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n    return {self._key: {self._operator: self._value}}\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Lt","title":"<code>Lt</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$lt</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Lt(KeyValueOperator):\n    \"\"\"`$lt` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Lte","title":"<code>Lte</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$lte</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Lte(KeyValueOperator):\n    \"\"\"`$lte` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Ne","title":"<code>Ne</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$ne</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Ne(KeyValueOperator):\n    \"\"\"`$ne` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Nor","title":"<code>Nor</code>","text":"<p>               Bases: <code>ClauseOperator</code></p> <p><code>$nor</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Nor(ClauseOperator):\n    \"\"\"`$nor` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Not","title":"<code>Not</code>","text":"<p>               Bases: <code>ClauseOperator</code></p> <p><code>$not</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Not(ClauseOperator):\n    \"\"\"`$not` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.NotIn","title":"<code>NotIn</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$nin</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class NotIn(KeyValueOperator):\n    \"\"\"`$nin` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n    _operator = \"$nin\"\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>ClauseOperator</code></p> <p><code>$or</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Or(ClauseOperator):\n    \"\"\"`$or` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Raw","title":"<code>Raw</code>","text":"<p>Clause that wraps a raw, MongoDB query dict.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Raw:\n    \"\"\"Clause that wraps a raw, MongoDB query dict.\"\"\"\n\n    __slots__ = (\"_data\",)\n\n    def __init__(self, value: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            value: The raw MongoDB query dict.\n        \"\"\"\n        self._data = value\n\n    def to_mongo(self) -&gt; dict[str, Any]:\n        \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n        return {**self._data}  # Just a shallow copy\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Raw.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The raw MongoDB query dict.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, value: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        value: The raw MongoDB query dict.\n    \"\"\"\n    self._data = value\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Raw.to_mongo","title":"<code>to_mongo()</code>","text":"<p>Converts the operator to a MongoDB-compatible dict.</p> Source code in <code>motorhead/operator.py</code> <pre><code>def to_mongo(self) -&gt; dict[str, Any]:\n    \"\"\"Converts the operator to a MongoDB-compatible dict.\"\"\"\n    return {**self._data}  # Just a shallow copy\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Regex","title":"<code>Regex</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$regex</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Regex(KeyValueOperator):\n    \"\"\"`$regex` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, key: str | Field, value: str) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, str):\n            raise ValueError(\"Regex field only accepts str values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Regex.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>str</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: str) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, str):\n        raise ValueError(\"Regex field only accepts str values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Size","title":"<code>Size</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$size</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Size(KeyValueOperator):\n    \"\"\"`$size` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, key: str | Field, value: int) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, int):\n            raise ValueError(\"Size field only accepts int values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Size.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>int</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: int) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, int):\n        raise ValueError(\"Size field only accepts int values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Type","title":"<code>Type</code>","text":"<p>               Bases: <code>KeyValueOperator</code></p> <p><code>$type</code> MongoDB operator.</p> Source code in <code>motorhead/operator.py</code> <pre><code>class Type(KeyValueOperator):\n    \"\"\"`$type` MongoDB operator.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, key: str | Field, value: str) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            key: The operator's key (the document attribute name).\n            value: The operator's value.\n        \"\"\"\n        if not isinstance(value, str):\n            raise ValueError(\"Type field only accepts string values.\")\n        super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.Type.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Field</code> <p>The operator's key (the document attribute name).</p> required <code>value</code> <code>str</code> <p>The operator's value.</p> required Source code in <code>motorhead/operator.py</code> <pre><code>def __init__(self, key: str | Field, value: str) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        key: The operator's key (the document attribute name).\n        value: The operator's value.\n    \"\"\"\n    if not isinstance(value, str):\n        raise ValueError(\"Type field only accepts string values.\")\n    super().__init__(key, value)\n</code></pre>"},{"location":"api/operator/#motorhead.operator.ensure_dict","title":"<code>ensure_dict(data)</code>","text":"<p>Converts the given value to a dict.</p> Source code in <code>motorhead/operator.py</code> <pre><code>def ensure_dict(data: dict[str, Any] | Clause) -&gt; dict[str, Any]:\n    \"\"\"Converts the given value to a dict.\"\"\"\n    return data.to_mongo() if hasattr(data, \"to_mongo\") else data\n</code></pre>"},{"location":"api/query/","title":"Query","text":""},{"location":"api/query/#motorhead.query","title":"<code>motorhead.query</code>","text":""},{"location":"api/query/#motorhead.query.Field","title":"<code>Field</code>","text":"<p>Queryable field with support for MongoDB operators in the form of overridden built-in operators or MongoDB-specific methods.</p> Source code in <code>motorhead/query.py</code> <pre><code>class Field:\n    \"\"\"\n    Queryable field with support for MongoDB operators in the form of\n    overridden built-in operators or MongoDB-specific methods.\n    \"\"\"\n\n    __slots__ = (\"_name\",)\n\n    def __init__(self, name: str) -&gt; None:\n        self._name = name\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        The name of the field as well as the name of the corresponding property\n        in the MongoDB model.\n        \"\"\"\n        return self._name\n\n    # -- Operators\n\n    def __lt__(self, value: Any) -&gt; Query:\n        return Query(Lt(self._name, value))\n\n    def __le__(self, value: Any) -&gt; Query:\n        return Query(Lte(self._name, value))\n\n    def __eq__(self, value: Any) -&gt; Query:  # type: ignore[override]\n        if isinstance(value, (list, set, tuple, dict)):\n            return Query(Eq(self._name, value))\n\n        return Query(DirectEq(self._name, value))\n\n    def __ne__(self, value: Any) -&gt; Query:  # type: ignore[override]\n        return Query(Ne(self._name, value))\n\n    def __gt__(self, value: Any) -&gt; Query:\n        return Query(Gt(self._name, value))\n\n    def __ge__(self, value: Any) -&gt; Query:\n        return Query(Gte(self._name, value))\n\n    # -- Methods\n\n    def All(self, value: list[Any]) -&gt; Query:\n        \"\"\"\n        `$all` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(All(self._name, value))\n\n    def ElemMatch(self, value: dict[str, Any]) -&gt; Query:\n        \"\"\"\n        `$elemMatch` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(ElemMatch(self._name, value))\n\n    def Exists(self, value: bool) -&gt; Query:\n        \"\"\"\n        `$exists` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(Exists(self._name, value))\n\n    def In(self, value: Any) -&gt; Query:\n        \"\"\"\n        `$in` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(In(self._name, value))\n\n    def NotIn(self, value: Any) -&gt; Query:\n        \"\"\"\n        `$nin` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(NotIn(self._name, value))\n\n    def Regex(self, value: str) -&gt; Query:\n        \"\"\"\n        `$regex` operator.\n\n        Arguments:\n            value: The regular expression.\n        \"\"\"\n        return Query(Regex(self._name, value))\n\n    def Size(self, value: int) -&gt; Query:\n        \"\"\"\n        `$size` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(Size(self._name, value))\n\n    def Type(self, value: str) -&gt; Query:\n        \"\"\"\n        `$type` operator.\n\n        Arguments:\n            value: The operator's argument.\n        \"\"\"\n        return Query(Type(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of the field as well as the name of the corresponding property in the MongoDB model.</p>"},{"location":"api/query/#motorhead.query.Field.All","title":"<code>All(value)</code>","text":"<p><code>$all</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>list[Any]</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def All(self, value: list[Any]) -&gt; Query:\n    \"\"\"\n    `$all` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(All(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.ElemMatch","title":"<code>ElemMatch(value)</code>","text":"<p><code>$elemMatch</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def ElemMatch(self, value: dict[str, Any]) -&gt; Query:\n    \"\"\"\n    `$elemMatch` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(ElemMatch(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.Exists","title":"<code>Exists(value)</code>","text":"<p><code>$exists</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def Exists(self, value: bool) -&gt; Query:\n    \"\"\"\n    `$exists` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(Exists(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.In","title":"<code>In(value)</code>","text":"<p><code>$in</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def In(self, value: Any) -&gt; Query:\n    \"\"\"\n    `$in` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(In(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.NotIn","title":"<code>NotIn(value)</code>","text":"<p><code>$nin</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def NotIn(self, value: Any) -&gt; Query:\n    \"\"\"\n    `$nin` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(NotIn(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.Regex","title":"<code>Regex(value)</code>","text":"<p><code>$regex</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The regular expression.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def Regex(self, value: str) -&gt; Query:\n    \"\"\"\n    `$regex` operator.\n\n    Arguments:\n        value: The regular expression.\n    \"\"\"\n    return Query(Regex(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.Size","title":"<code>Size(value)</code>","text":"<p><code>$size</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def Size(self, value: int) -&gt; Query:\n    \"\"\"\n    `$size` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(Size(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Field.Type","title":"<code>Type(value)</code>","text":"<p><code>$type</code> operator.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The operator's argument.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def Type(self, value: str) -&gt; Query:\n    \"\"\"\n    `$type` operator.\n\n    Arguments:\n        value: The operator's argument.\n    \"\"\"\n    return Query(Type(self._name, value))\n</code></pre>"},{"location":"api/query/#motorhead.query.Query","title":"<code>Query</code>","text":"<p>Query implementation.</p> Source code in <code>motorhead/query.py</code> <pre><code>class Query:\n    \"\"\"\n    Query implementation.\n    \"\"\"\n\n    __slots__ = (\"_clause\",)\n\n    def __init__(self, clause: Clause | None = None) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            clause: The default clause of the query.\n        \"\"\"\n        self._clause = clause\n\n    def __and__(self, value: Clause) -&gt; Query:\n        \"\"\"The `&amp;` operator, produces a `Query`.\"\"\"\n        result = self.clone()\n        clause = value._clause if isinstance(value, Query) else value\n        if clause is None:\n            result._clause = self._clause\n        elif isinstance(self._clause, And):\n            result._clause = And(*self._clause.clauses, clause)\n        else:\n            result._clause = clause if self._clause is None else And(self._clause, clause)\n\n        return result\n\n    def __or__(self, value: Clause) -&gt; Query:\n        \"\"\"The `|` operator, produces a `Query`.\"\"\"\n        result = self.clone()\n        clause = value._clause if isinstance(value, Query) else value\n        if clause is None:\n            result._clause = self._clause\n        elif isinstance(self._clause, Or):\n            result._clause = Or(*self._clause.clauses, clause)\n        else:\n            result._clause = clause if self._clause is None else Or(self._clause, clause)\n\n        return result\n\n    def clone(self) -&gt; Query:\n        \"\"\"\n        Returns a clone of the query.\n        \"\"\"\n        result = type(self)()\n        self._clone_attributes(result)\n        return result\n\n    def _clone_attributes(self, item: Query) -&gt; None:\n        \"\"\"\n        Clones the attributes of the query.\n\n        Arguments:\n            item: The query on which clonable properties must be set.\n        \"\"\"\n        item._clause = self._clause\n\n    def to_mongo(self) -&gt; MongoQuery:\n        \"\"\"\n        Returns the `MongoQuery` representation of the query.\n        \"\"\"\n        return {} if self._clause is None else self._clause.to_mongo()\n</code></pre>"},{"location":"api/query/#motorhead.query.Query.__and__","title":"<code>__and__(value)</code>","text":"<p>The <code>&amp;</code> operator, produces a <code>Query</code>.</p> Source code in <code>motorhead/query.py</code> <pre><code>def __and__(self, value: Clause) -&gt; Query:\n    \"\"\"The `&amp;` operator, produces a `Query`.\"\"\"\n    result = self.clone()\n    clause = value._clause if isinstance(value, Query) else value\n    if clause is None:\n        result._clause = self._clause\n    elif isinstance(self._clause, And):\n        result._clause = And(*self._clause.clauses, clause)\n    else:\n        result._clause = clause if self._clause is None else And(self._clause, clause)\n\n    return result\n</code></pre>"},{"location":"api/query/#motorhead.query.Query.__init__","title":"<code>__init__(clause=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>clause</code> <code>Clause | None</code> <p>The default clause of the query.</p> <code>None</code> Source code in <code>motorhead/query.py</code> <pre><code>def __init__(self, clause: Clause | None = None) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        clause: The default clause of the query.\n    \"\"\"\n    self._clause = clause\n</code></pre>"},{"location":"api/query/#motorhead.query.Query.__or__","title":"<code>__or__(value)</code>","text":"<p>The <code>|</code> operator, produces a <code>Query</code>.</p> Source code in <code>motorhead/query.py</code> <pre><code>def __or__(self, value: Clause) -&gt; Query:\n    \"\"\"The `|` operator, produces a `Query`.\"\"\"\n    result = self.clone()\n    clause = value._clause if isinstance(value, Query) else value\n    if clause is None:\n        result._clause = self._clause\n    elif isinstance(self._clause, Or):\n        result._clause = Or(*self._clause.clauses, clause)\n    else:\n        result._clause = clause if self._clause is None else Or(self._clause, clause)\n\n    return result\n</code></pre>"},{"location":"api/query/#motorhead.query.Query.clone","title":"<code>clone()</code>","text":"<p>Returns a clone of the query.</p> Source code in <code>motorhead/query.py</code> <pre><code>def clone(self) -&gt; Query:\n    \"\"\"\n    Returns a clone of the query.\n    \"\"\"\n    result = type(self)()\n    self._clone_attributes(result)\n    return result\n</code></pre>"},{"location":"api/query/#motorhead.query.Query.to_mongo","title":"<code>to_mongo()</code>","text":"<p>Returns the <code>MongoQuery</code> representation of the query.</p> Source code in <code>motorhead/query.py</code> <pre><code>def to_mongo(self) -&gt; MongoQuery:\n    \"\"\"\n    Returns the `MongoQuery` representation of the query.\n    \"\"\"\n    return {} if self._clause is None else self._clause.to_mongo()\n</code></pre>"},{"location":"api/query/#motorhead.query.Queryable","title":"<code>Queryable</code>","text":"<p>Base class for queryable models.</p> <p>It expects a Pydantic <code>BaseModel</code> class during subclassing in its <code>model</code> argument and adds a queryable <code>Field</code> descriptor to the subclass for each field of the Pydantic model.</p> <p>Example:</p> <pre><code>from pydantic import BaseModel\n\nclass Person(BaseModel):\n    name: str\n    lucky_number: int\n\nclass QPerson(Queryable, model=Person):\n    __slots__ = ()\n</code></pre> <p>It's recommended to use the <code>Q</code> helper to achieve the above result, so you can have at least ORM-level type hints and autocompletion for the created queryable class.</p> <pre><code>from pydantic import BaseModel\n\nclass Person(BaseModel):\n    name: str\n    lucky_number: int\n\nQPerson = Q(Person)\n</code></pre> Source code in <code>motorhead/query.py</code> <pre><code>class Queryable:\n    \"\"\"\n    Base class for queryable models.\n\n    It expects a Pydantic `BaseModel` class during subclassing in its `model` argument and\n    adds a queryable `Field` descriptor to the subclass for each field of the Pydantic model.\n\n    Example:\n\n    ```python\n    from pydantic import BaseModel\n\n    class Person(BaseModel):\n        name: str\n        lucky_number: int\n\n    class QPerson(Queryable, model=Person):\n        __slots__ = ()\n    ```\n\n    It's recommended to use the `Q` helper to achieve the above result, so you can have\n    at least ORM-level type hints and autocompletion for the created queryable class.\n\n    ```python\n    from pydantic import BaseModel\n\n    class Person(BaseModel):\n        name: str\n        lucky_number: int\n\n    QPerson = Q(Person)\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init_subclass__(cls, *, model: type[BaseModel]) -&gt; None:\n        \"\"\"\n        Subclass initialization.\n\n        Arguments:\n            model: The Pydantic model the `Queryable` is created for.\n        \"\"\"\n        super().__init_subclass__()\n        for name, info in model.model_fields.items():\n            field_name = name\n            if name == \"id\" and info.alias == \"_id\":\n                field_name = \"_id\"\n\n            setattr(cls, name, Field(field_name))\n</code></pre>"},{"location":"api/query/#motorhead.query.Queryable.__init_subclass__","title":"<code>__init_subclass__(*, model)</code>","text":"<p>Subclass initialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model the <code>Queryable</code> is created for.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def __init_subclass__(cls, *, model: type[BaseModel]) -&gt; None:\n    \"\"\"\n    Subclass initialization.\n\n    Arguments:\n        model: The Pydantic model the `Queryable` is created for.\n    \"\"\"\n    super().__init_subclass__()\n    for name, info in model.model_fields.items():\n        field_name = name\n        if name == \"id\" and info.alias == \"_id\":\n            field_name = \"_id\"\n\n        setattr(cls, name, Field(field_name))\n</code></pre>"},{"location":"api/query/#motorhead.query.Q","title":"<code>Q(model)</code>","text":"<p>Creates a new <code>Queryable</code> class that can be used to construct queries for documents with the given Pydantic model.</p> <p>The created <code>Queryable</code> class will have a property (<code>Field</code>) for all properties that were declared in the given Pydantic class. For usage examples and more details, plase see <code>Queryable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[_T]</code> <p>The Pydantic model the <code>Queryable</code> class should be created for.</p> required Source code in <code>motorhead/query.py</code> <pre><code>def Q(model: type[_T]) -&gt; type[_T]:\n    \"\"\"\n    Creates a new `Queryable` class that can be used to construct queries for documents\n    with the given Pydantic model.\n\n    The created `Queryable` class will have a property (`Field`) for all properties\n    that were declared in the given Pydantic class. For usage examples and more details,\n    plase see `Queryable`.\n\n    Arguments:\n        model: The Pydantic model the `Queryable` class should be created for.\n    \"\"\"\n\n    class Result(Queryable, model=model):\n        __slots__ = ()\n\n    return Result  # type: ignore[return-value]\n</code></pre>"},{"location":"api/service/","title":"Service","text":""},{"location":"api/service/#motorhead.service","title":"<code>motorhead.service</code>","text":""},{"location":"api/service/#motorhead.service.BaseService","title":"<code>BaseService</code>","text":"<p>               Bases: <code>Generic[TInsert, TUpdate, TPrimaryKey]</code></p> <p>Base service with typed utility methods for MongoDB (<code>motor</code> asyncio).</p> <p>The service provides a limited subset of <code>motor</code>'s capabilities.</p> <p>For undocumented keyword arguments, please see the <code>motor</code> or <code>pymongo</code> documentation.</p> <p>For delete rule support, see <code>DeleteRule</code>, <code>delete_many()</code>, and <code>delete_one()</code>.</p> <p>For insert and update data validation, see <code>Validator</code>, <code>_validate_insert()</code>, and <code>_validate_update()</code></p> Class attributes <p>collection_name: The name of the collection the service operates on. Must be set by subclasses. collection_options: Optional <code>CollectionOptions</code> dict.</p> Source code in <code>motorhead/service.py</code> <pre><code>class BaseService(Generic[TInsert, TUpdate, TPrimaryKey]):\n    \"\"\"\n    Base service with typed utility methods for MongoDB (`motor` asyncio).\n\n    The service provides a limited subset of `motor`'s capabilities.\n\n    For undocumented keyword arguments, please see the `motor` or `pymongo` documentation.\n\n    For delete rule support, see `DeleteRule`, `delete_many()`, and `delete_one()`.\n\n    For insert and update data validation, see `Validator`, `_validate_insert()`, and `_validate_update()`\n\n    Class attributes:\n        collection_name: The name of the collection the service operates on. Must be set by subclasses.\n        collection_options: Optional `CollectionOptions` dict.\n    \"\"\"\n\n    __slots__ = (\n        \"_collection\",\n        \"_database\",\n        \"_supports_transactions\",\n    )\n\n    collection_name: ClassVar[str]\n    \"\"\"\n    The name of the collection the service operates on. Must be set by subclasses.\n    \"\"\"\n\n    collection_options: ClassVar[CollectionOptions | None] = None\n    \"\"\"\n    Optional `CollectionOptions` dict.\n    \"\"\"\n\n    indexes: ClassVar[dict[str, IndexData] | None] = None\n    \"\"\"\n    The full description of the indexes (if any) of the collection.\n    \"\"\"\n\n    service_config: ClassVar[ServiceConfig] = {}\n    \"\"\"Service configuration. Partial override of parent class configuration is not supported.\"\"\"\n\n    def __init__(self, database: AgnosticDatabase) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            database: The database driver.\n        \"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"Service.collection_name is not initialized.\")\n\n        self._database = database\n        self._collection: AgnosticCollection | None = None\n        self._supports_transactions: bool | None = None\n\n    @property\n    def client(self) -&gt; AgnosticClient:\n        \"\"\"\n        The database client.\n        \"\"\"\n        return self._database.client\n\n    @property\n    def collection(self) -&gt; AgnosticCollection:\n        \"\"\"\n        The collection instance of the service.\n        \"\"\"\n        if self._collection is None:\n            self._collection = self._create_collection()\n\n        return self._collection\n\n    async def supports_transactions(self) -&gt; bool:\n        \"\"\"\n        Queries the database if it supports transactions or not.\n\n        Note: transactions are only supported in replica set configuration.\n        \"\"\"\n        if self._supports_transactions is None:\n            self._supports_transactions = \"system.replset\" in (\n                await self.client[\"local\"].list_collection_names()\n            )\n\n        return self._supports_transactions\n\n    def aggregate(\n        self,\n        pipeline: Sequence[dict[str, Any]],\n        session: AgnosticClientSession | None = None,\n        **kwargs: Any,\n    ) -&gt; AgnosticCommandCursor:\n        \"\"\"\n        Performs an aggregation.\n\n        For undocumented keyword arguments, see the documentation of\n        `pymongo.collection.Collection.aggregate()`.\n\n        Arguments:\n            pipeline: The aggregation pipeline.\n            session: An optional session to use.\n        \"\"\"\n        return self.collection.aggregate(pipeline, session=session, **kwargs)\n\n    async def count_documents(\n        self, query: ClauseOrMongoQuery | None = None, *, options: FindOptions | None = None\n    ) -&gt; int:\n        \"\"\"\n        Returns the number of documents that match the given query.\n\n        Arguments:\n            query: The query object.\n            options: Query options, see the arguments of `collection.count_documents()` for details.\n\n        Returns:\n            The number of matching documents.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return await self.collection.count_documents(query, **(options or {}))\n\n    async def create_index(\n        self,\n        keys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n        *,\n        name: str,\n        unique: bool = False,\n        session: AgnosticClientSession | None = None,\n        background: bool = False,\n        collation: Collation | None = None,\n        sparse: bool = False,\n        **kwargs: Any,\n    ) -&gt; str:\n        \"\"\"\n        Creates the specified index on collection of the service.\n\n        Arguments:\n            keys: Index description.\n            name: Index name.\n            unique: Whether to create a uniqueness constraint on the index.\n            session: An optional session to use.\n            background: Whether the index should be created in the background.\n            collation: A `Collation` instance.\n            sparse: Whether to omit documents from the index that doesn't have the indexed field.\n        \"\"\"\n        return await self.collection.create_index(\n            keys,\n            name=name,\n            unique=unique,\n            session=session,\n            background=background,\n            collation=collation,\n            sparse=sparse,\n            **kwargs,\n        )\n\n    async def create_indexes(self, session: AgnosticClientSession | None = None) -&gt; None:\n        \"\"\"\n        Creates all declared indexes (see cls.indexes) on the collection of the service.\n\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\n        if self.indexes is None:\n            return\n\n        for name, idx in self.indexes.items():\n            await self.create_index(\n                idx.keys,\n                name=name,\n                unique=idx.unique,\n                background=idx.background,\n                collation=idx.collation,\n                sparse=idx.sparse,\n                session=session,\n                **idx.extra,\n            )\n\n    async def drop_index(\n        self,\n        index_or_name: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n        session: AgnosticClientSession | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Drops the given index from the collection of the service.\n\n        Arguments:\n            index_or_name: The index to drop.\n            session: An optional session to use.\n        \"\"\"\n        return await self.collection.drop_index(\n            index_or_name,\n            session=session,\n            **kwargs,\n        )\n\n    async def drop_indexes(self, session: AgnosticClientSession | None = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Drops all indexes from the collection of the service.\n\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\n        return await self.collection.drop_indexes(session, **kwargs)\n\n    def list_indexes(\n        self,\n        session: AgnosticClientSession | None = None,\n        **kwargs: Any,\n    ) -&gt; AgnosticLatentCommandCursor:\n        \"\"\"\n        Returns a cursor over the indexes of the collection of the service.\n\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\n        return self.collection.list_indexes(session, **kwargs)\n\n    async def delete_by_id(\n        self,\n        id: TPrimaryKey,\n        *,\n        options: DeleteOptions | None = None,\n    ) -&gt; DeleteResult:\n        \"\"\"\n        Deletes the document with the given ID.\n\n        This method is just a convenience wrapper around `delete_one()`, see that\n        method for more details.\n\n        Arguments:\n            id: The ID of the document to delete.\n            options: Delete options, see the arguments of `collection.delete_one()`.\n\n        Returns:\n            The result of the operation.\n        \"\"\"\n        return await self.delete_one({\"_id\": id}, options=options)\n\n    async def delete_many(\n        self,\n        query: ClauseOrMongoQuery | None,\n        *,\n        options: DeleteOptions | None = None,\n    ) -&gt; DeleteResult:\n        \"\"\"\n        The default `delete_many()` implementation of the service.\n\n        The method enforces delete rules and executes the operation as follows:\n\n        1. Enforce `\"deny\"` delete rules.\n        2. Enforce `\"pre\"` delete rules.\n        3. Execute the delete operation.\n        4. Enforce `\"post\"` delete rules.\n\n        See `DeleteRule` for more information.\n\n        Arguments:\n            query: Query object that matches the documents that should be deleted.\n            options: Delete options, see the arguments of `collection.delete_many()`.\n\n        Returns:\n            The result of the operation.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        session_manager = self._get_session_context_manager(\n            options.get(\"session\", None) if options else None\n        )\n        async with await session_manager() as session:\n            opts: DeleteOptions = options or {}\n            opts[\"session\"] = session\n            ctxman = (\n                nullcontext\n                if (\n                    session.in_transaction  # type: ignore[truthy-function]\n                    or not await self.supports_transactions()\n                )\n                else session.start_transaction\n            )\n\n            ids = await self.find_ids(query, session=session) if self._has_delete_rules() else None\n\n            has_ids = ids is not None and len(ids) &gt; 0\n\n            async with ctxman():\n                if has_ids:\n                    await self._validate_deny_delete(\n                        session,\n                        ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                    )\n                    await self._validate_pre_delete(\n                        session,\n                        ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                    )\n\n                result = await self.collection.delete_many(query, **opts)\n\n                if has_ids:\n                    await self._validate_post_delete(\n                        session,\n                        ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                    )\n\n                return result\n\n    async def delete_one(\n        self,\n        query: ClauseOrMongoQuery | None,\n        *,\n        options: DeleteOptions | None = None,\n    ) -&gt; DeleteResult:\n        \"\"\"\n        The default `delete_one()` implementation of the service.\n\n        The method enforces delete rules and executes the operation as follows:\n\n        1. Enforce `\"deny\"` delete rules.\n        2. Enforce `\"pre\"` delete rules.\n        3. Execute the delete operation.\n        4. Enforce `\"post\"` delete rules.\n\n        See `DeleteRule` for more information.\n\n        Arguments:\n            query: Query object that matches the document that should be deleted.\n            options: Delete options, see the arguments of `collection.delete_one()`.\n\n        Returns:\n            The result of the operation.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        session_manager = self._get_session_context_manager(\n            options.get(\"session\", None) if options else None\n        )\n        async with await session_manager() as session:\n            opts: DeleteOptions = options or {}\n            opts[\"session\"] = session\n            ctxman = (\n                nullcontext\n                if (\n                    session.in_transaction  # type: ignore[truthy-function]\n                    or not await self.supports_transactions()\n                )\n                else session.start_transaction\n            )\n\n            ids = await self.find_ids(query, session=session) if self._has_delete_rules() else None\n\n            async with ctxman():\n                if ids is not None:\n                    if len(ids) &gt; 1:\n                        # Only when the service has delete rules...\n                        raise ValueError(\"Ambigous delete_one() - multiple documents match the query.\")\n\n                    await self._validate_deny_delete(session, ids)\n                    await self._validate_pre_delete(session, ids)\n\n                result = await self.collection.delete_one(query, **opts)\n\n                if ids is not None:\n                    await self._validate_post_delete(session, ids)\n\n                return result\n\n    async def exists(self, id: TPrimaryKey, *, options: FindOptions | None = None) -&gt; bool:\n        \"\"\"\n        Returns whether the document with the given ID exists.\n\n        Arguments:\n            id: The ID of the document to check.\n            options: Query options, see the arguments of `collection.count_documents()` for details.\n\n        Returns:\n            Whether the document with the given ID exists.\n        \"\"\"\n        return await self.count_documents({\"_id\": id}, options=options) == 1\n\n    def find(\n        self,\n        query: ClauseOrMongoQuery | None = None,\n        projection: MongoProjection | None = None,\n        *,\n        options: FindOptions | None = None,\n    ) -&gt; AgnosticCursor:\n        \"\"\"\n        The default `find()` implementation of the service.\n\n        Arguments:\n            query: The query object.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n\n        Returns:\n            An async database cursor.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return self.collection.find(query, projection, **(options or {}))\n\n    async def find_ids(\n        self,\n        query: ClauseOrMongoQuery | None,\n        *,\n        session: AgnosticClientSession | None = None,\n    ) -&gt; list[TPrimaryKey]:\n        \"\"\"\n        Returns the IDs of all documents that match the given query.\n\n        Arguments:\n            query: The query object.\n            session: An optional database session to use.\n\n        Returns:\n            The IDs of all matching documents.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return [\n            doc[\"_id\"]\n            for doc in await self.collection.find(query, {\"_id\": True}, session=session).to_list(None)\n        ]\n\n    async def find_one(\n        self,\n        query: ClauseOrMongoQuery | None = None,\n        projection: MongoProjection | None = None,\n        *,\n        options: FindOptions | None = None,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        The default `find_one()` implementation of the service.\n\n        Arguments:\n            query: The query object.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n\n        Returns:\n            A single matching document or `None` if there are no matches.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return await self.collection.find_one(query, projection, **(options or {}))\n\n    async def get_by_id(\n        self,\n        id: TPrimaryKey,\n        projection: MongoProjection | None = None,\n        *,\n        options: FindOptions | None = None,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Returns the document with the given ID if it exists.\n\n        Arguments:\n            id: The ID of the queried document.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n\n        Returns:\n            The queried document if such a document exists.\n        \"\"\"\n        return await self.find_one({\"_id\": id}, projection, options=options)\n\n    async def create(self, data: TInsert, *, options: InsertOneOptions | None = None) -&gt; dict[str, Any]:\n        \"\"\"\n        Inserts the given data into the collection and immediately queries\n        and returns the created document.\n\n        Arguments:\n            data: The data to be inserted.\n            options: Insert options, see the arguments of `collection.insert_one()` for details.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            ServiceException: If the service failed to access the newly created document.\n            Exception: If the data is invalid.\n        \"\"\"\n        insert_result = await self.insert_one(data, options=options)\n        result = await self.get_by_id(insert_result.inserted_id)\n        if result is None:\n            raise ServiceException(\"Failed to query the inserted document by its ID.\")\n\n        return result\n\n    async def insert_many(\n        self, data: Iterable[TInsert], *, options: InsertManyOptions | None = None\n    ) -&gt; InsertManyResult:\n        \"\"\"\n        Inserts all the given objects into the collection.\n\n        Arguments:\n            data: The documents to be inserted.\n            options: Insert options, see the arguments of `collection.insert_many()` for details.\n\n        Returns\n            The result of the operation.\n\n        Raises:\n            Exception: If any of the documents is invalid.\n        \"\"\"\n        insert_data = [await self._prepare_for_insert(d) for d in data]\n        return await self.collection.insert_many(\n            insert_data,\n            **(options or {}),\n        )\n\n    async def insert_one(\n        self, data: TInsert, *, options: InsertOneOptions | None = None\n    ) -&gt; InsertOneResult:\n        \"\"\"\n        Inserts the given data into the collection.\n\n        Arguments:\n            data: The data to be inserted.\n            options: Insert options, see the arguments of `collection.insert_one()` for details.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        return await self.collection.insert_one(\n            await self._prepare_for_insert(data),\n            **(options or {}),\n        )\n\n    async def update(\n        self,\n        id: TPrimaryKey,\n        changes: TUpdate,\n        *,\n        options: UpdateOneOptions | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Updates the document with the given ID and immediately queries and returns\n        the updated document.\n\n        Arguments:\n            id: The ID of the document to update.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_one()` for details.\n\n        Returns:\n            The updated document.\n\n        Raises:\n            ServiceException: If the service failed to query the updated document.\n            Exception: If the data is invalid.\n        \"\"\"\n        await self.update_by_id(id, changes, options=options)\n        result = await self.get_by_id(id)\n        if result is None:\n            raise ServiceException(\"Failed to query the updated document by its ID.\")\n\n        return result\n\n    async def update_by_id(\n        self,\n        id: TPrimaryKey,\n        changes: TUpdate,\n        *,\n        options: UpdateOneOptions | None = None,\n    ) -&gt; UpdateResult:\n        \"\"\"\n        Updates the document with the given ID.\n\n        Arguments:\n            id: The ID of the document to update.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_one()` for details.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        return await self.update_one({\"_id\": id}, changes, options=options)\n\n    async def update_many(\n        self,\n        query: ClauseOrMongoQuery | None,\n        changes: TUpdate,\n        *,\n        options: UpdateManyOptions | None = None,\n    ) -&gt; UpdateResult:\n        \"\"\"\n        Updates the documents that match the given query.\n\n        Arguments:\n            query: Query that matches the documents that should be updated.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_many()` for details.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return await self.collection.update_many(\n            query,\n            await self._prepare_for_update(changes, query),\n            **(options or {}),\n        )\n\n    async def update_one(\n        self,\n        query: ClauseOrMongoQuery | None,\n        changes: TUpdate,\n        *,\n        options: UpdateOneOptions | None = None,\n    ) -&gt; UpdateResult:\n        \"\"\"\n        Updates the first document that matches the given query.\n\n        Arguments:\n            query: Query that matches the document that should be updated.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_one()` for details.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        query = {} if query is None else ensure_dict(query)\n        return await self.collection.update_one(\n            query,\n            await self._prepare_for_update(changes, query),\n            **(options or {}),\n        )\n\n    @classmethod\n    def get_objectid_fields(cls, model: type[BaseModel]) -&gt; set[str]:\n        \"\"\"\n        Returns the names of all `ObjectId` fields.\n\n        Arguments:\n            model: The model to collect `ObjectId` field\n        \"\"\"\n        result: set[str] = set()\n        for name, info in model.model_fields.items():\n            if info.annotation is None:\n                continue\n\n            if args := get_args(info.annotation):\n                try:\n                    if any(issubclass(a, ObjectId) for a in args):\n                        result.add(name)\n                except TypeError:\n                    continue\n            elif issubclass(info.annotation, ObjectId):\n                result.add(name)\n\n        return result\n\n    async def _convert_for_insert(self, data: TInsert) -&gt; dict[str, Any]:\n        \"\"\"\n        Converts the given piece of data to its database representation.\n\n        Arguments:\n            data: The data to be inserted.\n\n        Returns:\n            The MongoDB-compatible, insertable data.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        return self._mongo_dump(\n            data,\n            exclude_unset=self.service_config.get(\n                \"exclude_unset_on_insert\", _default_service_config.exclude_unset_on_insert\n            ),\n        )\n\n    async def _convert_for_update(self, data: TUpdate) -&gt; UpdateObject:\n        \"\"\"\n        Converts the given piece of data into an update object.\n\n        Arguments:\n            data: The update data.\n\n        Returns:\n            The MongoDB-compatible update object.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        return {\"$set\": self._mongo_dump(data, exclude_unset=True)}\n\n    def _create_collection(self) -&gt; AgnosticCollection:\n        \"\"\"\n        Creates a new `AgnosticCollection` instance for the service.\n        \"\"\"\n        return self._database.get_collection(self.collection_name, **(self.collection_options or {}))\n\n    def _delete_rules(\n        self,\n    ) -&gt; Generator[DeleteRule[\"BaseService[TInsert, TUpdate, TPrimaryKey]\", TPrimaryKey], None, None]:\n        \"\"\"\n        Generator that yields the delete rules that are registered on this service\n        in the order they are present in `__class__.__dict__`.\n        \"\"\"\n        for rule in self.__class__.__dict__.values():\n            if isinstance(rule, DeleteRule):\n                yield rule\n\n    def _has_delete_rules(self) -&gt; bool:\n        \"\"\"\n        Returns whether the service has any delete rules.\n        \"\"\"\n        return any(isinstance(rule, DeleteRule) for rule in self.__class__.__dict__.values())\n\n    def _get_session_context_manager(\n        self,\n        session: AgnosticClientSession | None,\n    ) -&gt; Callable[[], Coroutine[None, None, AbstractAsyncContextManager[AgnosticClientSession]]]:\n        \"\"\"\n        Returns a session context manager\n        \"\"\"\n        if session is None:\n            # Return a context manager that actually starts a session.\n            return self.client.start_session\n\n        async def start_session() -&gt; AbstractAsyncContextManager[AgnosticClientSession]:\n            @asynccontextmanager\n            async def ctx_manager() -&gt; AsyncGenerator[AgnosticClientSession, None]:\n                yield session\n\n            return ctx_manager()\n\n        return start_session\n\n    def _mongo_dump(self, data: BaseModel, *, exclude_unset: bool) -&gt; dict[str, Any]:\n        \"\"\"\n        Dumps the given model instance for consumption by MongoDB.\n\n        Arguments:\n            data: The model instance to dump.\n            exclude_unset: Whether to exclude fields that have not been explicitly set on the data.\n\n        Returns:\n            The MongoDB-compatible, dumped dictionary.\n        \"\"\"\n        objectid_fields = self.get_objectid_fields(type(data))\n        return {\n            **{\n                k: None if v is None else ObjectId(v)\n                for k, v in data.model_dump(\n                    include=objectid_fields,\n                    by_alias=True,\n                    exclude_unset=exclude_unset,\n                ).items()\n            },\n            **data.model_dump(\n                exclude=objectid_fields,\n                by_alias=True,\n                exclude_unset=exclude_unset,\n            ),\n        }\n\n    async def _prepare_for_insert(\n        self, data: TInsert, query: ClauseOrMongoQuery | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Validates the given piece of data and converts it into its database representation\n        if validation was successful.\n\n        Arguments:\n            data: The data to be inserted.\n            query: Query that matches the documents that will be updated.\n\n        Returns:\n            The MongoDB-compatible, insertable data.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        await self._validate_insert(data, query)\n        return await self._convert_for_insert(data)\n\n    async def _prepare_for_update(self, data: TUpdate, query: ClauseOrMongoQuery | None) -&gt; UpdateObject:\n        \"\"\"\n        Validates the given piece of data and converts it into an update object.\n\n        Arguments:\n            data: The update data.\n            query: Query that matches the documents that will be updated.\n\n        Returns:\n            The MongoDB-compatible update object.\n\n        Raises:\n            Exception: If the data is invalid.\n        \"\"\"\n        await self._validate_update(data, query)\n        return await self._convert_for_update(data)\n\n    async def _validate_insert(self, data: TInsert, query: ClauseOrMongoQuery | None = None) -&gt; None:\n        \"\"\"\n        Validates the given piece of data for insertion by executing all insert validators.\n\n        See `Validator` for more information.\n\n        Arguments:\n            query: Query that matches the documents that will be updated.\n            data: The data to validate.\n\n        Raises:\n            ValidationError: If validation failed.\n        \"\"\"\n        # Sequential validation, slow but safe.\n        for validator in self._validators():\n            if \"insert\" in validator.config:\n                await validator(self, data, query)\n\n    async def _validate_deny_delete(\n        self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n    ) -&gt; None:\n        \"\"\"\n        Executes all \"deny\" delete rules.\n\n        See `DeleteRule` for more information.\n\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n\n        Raises:\n            DeleteError: if one of the executed delete rules prevent the operation.\n        \"\"\"\n        for rule in self._delete_rules():\n            if isinstance(rule, DeleteRule) and rule.config == \"deny\":\n                await rule(self, session, ids)\n\n    async def _validate_pre_delete(\n        self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n    ) -&gt; None:\n        \"\"\"\n        Executes all \"pre\" delete rules.\n\n        See `DeleteRule` for more information.\n\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n\n        Raises:\n            DeleteError: if one of the executed delete rules fail.\n        \"\"\"\n        for rule in self._delete_rules():\n            if isinstance(rule, DeleteRule) and rule.config == \"pre\":\n                await rule(self, session, ids)\n\n    async def _validate_post_delete(\n        self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n    ) -&gt; None:\n        \"\"\"\n        Executes all \"post\" delete rules.\n\n        See `DeleteRule` for more information.\n\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n\n        Raises:\n            DeleteError: if one of the executed delete rules fail.\n        \"\"\"\n        for rule in self._delete_rules():\n            if isinstance(rule, DeleteRule) and rule.config == \"post\":\n                await rule(self, session, ids)\n\n    async def _validate_update(self, data: TUpdate, query: ClauseOrMongoQuery | None = None) -&gt; None:\n        \"\"\"\n        Validates the given piece of data for update by executing all update validators.\n\n        See `Validator` for more information.\n\n        Arguments:\n            data: The data to validate.\n            query: Query that matches the documents that will be updated.\n\n        Raises:\n            ValidationError: If validation failed.\n        \"\"\"\n        # Sequential validation, slow but safe.\n        for validator in self._validators():\n            if \"update\" in validator.config:\n                await validator(self, data, query)\n\n    def _validators(\n        self,\n    ) -&gt; Generator[Validator[\"BaseService[TInsert, TUpdate, TPrimaryKey]\", TInsert | TUpdate], None, None]:\n        \"\"\"\n        Generator that yields the validators that are registered on this service\n        in the order they are present in `__class__.__dict__`.\n        \"\"\"\n        for validator in self.__class__.__dict__.values():\n            if isinstance(validator, Validator):\n                yield validator\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.client","title":"<code>client</code>  <code>property</code>","text":"<p>The database client.</p>"},{"location":"api/service/#motorhead.service.BaseService.collection","title":"<code>collection</code>  <code>property</code>","text":"<p>The collection instance of the service.</p>"},{"location":"api/service/#motorhead.service.BaseService.collection_name","title":"<code>collection_name</code>  <code>class-attribute</code>","text":"<p>The name of the collection the service operates on. Must be set by subclasses.</p>"},{"location":"api/service/#motorhead.service.BaseService.collection_options","title":"<code>collection_options = None</code>  <code>class-attribute</code>","text":"<p>Optional <code>CollectionOptions</code> dict.</p>"},{"location":"api/service/#motorhead.service.BaseService.indexes","title":"<code>indexes = None</code>  <code>class-attribute</code>","text":"<p>The full description of the indexes (if any) of the collection.</p>"},{"location":"api/service/#motorhead.service.BaseService.service_config","title":"<code>service_config = {}</code>  <code>class-attribute</code>","text":"<p>Service configuration. Partial override of parent class configuration is not supported.</p>"},{"location":"api/service/#motorhead.service.BaseService.__init__","title":"<code>__init__(database)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>AgnosticDatabase</code> <p>The database driver.</p> required Source code in <code>motorhead/service.py</code> <pre><code>def __init__(self, database: AgnosticDatabase) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        database: The database driver.\n    \"\"\"\n    if self.collection_name is None:\n        raise ValueError(\"Service.collection_name is not initialized.\")\n\n    self._database = database\n    self._collection: AgnosticCollection | None = None\n    self._supports_transactions: bool | None = None\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._convert_for_insert","title":"<code>_convert_for_insert(data)</code>  <code>async</code>","text":"<p>Converts the given piece of data to its database representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The MongoDB-compatible, insertable data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _convert_for_insert(self, data: TInsert) -&gt; dict[str, Any]:\n    \"\"\"\n    Converts the given piece of data to its database representation.\n\n    Arguments:\n        data: The data to be inserted.\n\n    Returns:\n        The MongoDB-compatible, insertable data.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    return self._mongo_dump(\n        data,\n        exclude_unset=self.service_config.get(\n            \"exclude_unset_on_insert\", _default_service_config.exclude_unset_on_insert\n        ),\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._convert_for_update","title":"<code>_convert_for_update(data)</code>  <code>async</code>","text":"<p>Converts the given piece of data into an update object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TUpdate</code> <p>The update data.</p> required <p>Returns:</p> Type Description <code>UpdateObject</code> <p>The MongoDB-compatible update object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _convert_for_update(self, data: TUpdate) -&gt; UpdateObject:\n    \"\"\"\n    Converts the given piece of data into an update object.\n\n    Arguments:\n        data: The update data.\n\n    Returns:\n        The MongoDB-compatible update object.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    return {\"$set\": self._mongo_dump(data, exclude_unset=True)}\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._create_collection","title":"<code>_create_collection()</code>","text":"<p>Creates a new <code>AgnosticCollection</code> instance for the service.</p> Source code in <code>motorhead/service.py</code> <pre><code>def _create_collection(self) -&gt; AgnosticCollection:\n    \"\"\"\n    Creates a new `AgnosticCollection` instance for the service.\n    \"\"\"\n    return self._database.get_collection(self.collection_name, **(self.collection_options or {}))\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._delete_rules","title":"<code>_delete_rules()</code>","text":"<p>Generator that yields the delete rules that are registered on this service in the order they are present in <code>__class__.__dict__</code>.</p> Source code in <code>motorhead/service.py</code> <pre><code>def _delete_rules(\n    self,\n) -&gt; Generator[DeleteRule[\"BaseService[TInsert, TUpdate, TPrimaryKey]\", TPrimaryKey], None, None]:\n    \"\"\"\n    Generator that yields the delete rules that are registered on this service\n    in the order they are present in `__class__.__dict__`.\n    \"\"\"\n    for rule in self.__class__.__dict__.values():\n        if isinstance(rule, DeleteRule):\n            yield rule\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._get_session_context_manager","title":"<code>_get_session_context_manager(session)</code>","text":"<p>Returns a session context manager</p> Source code in <code>motorhead/service.py</code> <pre><code>def _get_session_context_manager(\n    self,\n    session: AgnosticClientSession | None,\n) -&gt; Callable[[], Coroutine[None, None, AbstractAsyncContextManager[AgnosticClientSession]]]:\n    \"\"\"\n    Returns a session context manager\n    \"\"\"\n    if session is None:\n        # Return a context manager that actually starts a session.\n        return self.client.start_session\n\n    async def start_session() -&gt; AbstractAsyncContextManager[AgnosticClientSession]:\n        @asynccontextmanager\n        async def ctx_manager() -&gt; AsyncGenerator[AgnosticClientSession, None]:\n            yield session\n\n        return ctx_manager()\n\n    return start_session\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._has_delete_rules","title":"<code>_has_delete_rules()</code>","text":"<p>Returns whether the service has any delete rules.</p> Source code in <code>motorhead/service.py</code> <pre><code>def _has_delete_rules(self) -&gt; bool:\n    \"\"\"\n    Returns whether the service has any delete rules.\n    \"\"\"\n    return any(isinstance(rule, DeleteRule) for rule in self.__class__.__dict__.values())\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._mongo_dump","title":"<code>_mongo_dump(data, *, exclude_unset)</code>","text":"<p>Dumps the given model instance for consumption by MongoDB.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseModel</code> <p>The model instance to dump.</p> required <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set on the data.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The MongoDB-compatible, dumped dictionary.</p> Source code in <code>motorhead/service.py</code> <pre><code>def _mongo_dump(self, data: BaseModel, *, exclude_unset: bool) -&gt; dict[str, Any]:\n    \"\"\"\n    Dumps the given model instance for consumption by MongoDB.\n\n    Arguments:\n        data: The model instance to dump.\n        exclude_unset: Whether to exclude fields that have not been explicitly set on the data.\n\n    Returns:\n        The MongoDB-compatible, dumped dictionary.\n    \"\"\"\n    objectid_fields = self.get_objectid_fields(type(data))\n    return {\n        **{\n            k: None if v is None else ObjectId(v)\n            for k, v in data.model_dump(\n                include=objectid_fields,\n                by_alias=True,\n                exclude_unset=exclude_unset,\n            ).items()\n        },\n        **data.model_dump(\n            exclude=objectid_fields,\n            by_alias=True,\n            exclude_unset=exclude_unset,\n        ),\n    }\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._prepare_for_insert","title":"<code>_prepare_for_insert(data, query=None)</code>  <code>async</code>","text":"<p>Validates the given piece of data and converts it into its database representation if validation was successful.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The MongoDB-compatible, insertable data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _prepare_for_insert(\n    self, data: TInsert, query: ClauseOrMongoQuery | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Validates the given piece of data and converts it into its database representation\n    if validation was successful.\n\n    Arguments:\n        data: The data to be inserted.\n        query: Query that matches the documents that will be updated.\n\n    Returns:\n        The MongoDB-compatible, insertable data.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    await self._validate_insert(data, query)\n    return await self._convert_for_insert(data)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._prepare_for_update","title":"<code>_prepare_for_update(data, query)</code>  <code>async</code>","text":"<p>Validates the given piece of data and converts it into an update object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TUpdate</code> <p>The update data.</p> required <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> required <p>Returns:</p> Type Description <code>UpdateObject</code> <p>The MongoDB-compatible update object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _prepare_for_update(self, data: TUpdate, query: ClauseOrMongoQuery | None) -&gt; UpdateObject:\n    \"\"\"\n    Validates the given piece of data and converts it into an update object.\n\n    Arguments:\n        data: The update data.\n        query: Query that matches the documents that will be updated.\n\n    Returns:\n        The MongoDB-compatible update object.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    await self._validate_update(data, query)\n    return await self._convert_for_update(data)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validate_deny_delete","title":"<code>_validate_deny_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"deny\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[TPrimaryKey]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules prevent the operation.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _validate_deny_delete(\n    self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n) -&gt; None:\n    \"\"\"\n    Executes all \"deny\" delete rules.\n\n    See `DeleteRule` for more information.\n\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n\n    Raises:\n        DeleteError: if one of the executed delete rules prevent the operation.\n    \"\"\"\n    for rule in self._delete_rules():\n        if isinstance(rule, DeleteRule) and rule.config == \"deny\":\n            await rule(self, session, ids)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validate_insert","title":"<code>_validate_insert(data, query=None)</code>  <code>async</code>","text":"<p>Validates the given piece of data for insertion by executing all insert validators.</p> <p>See <code>Validator</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> <code>None</code> <code>data</code> <code>TInsert</code> <p>The data to validate.</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If validation failed.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _validate_insert(self, data: TInsert, query: ClauseOrMongoQuery | None = None) -&gt; None:\n    \"\"\"\n    Validates the given piece of data for insertion by executing all insert validators.\n\n    See `Validator` for more information.\n\n    Arguments:\n        query: Query that matches the documents that will be updated.\n        data: The data to validate.\n\n    Raises:\n        ValidationError: If validation failed.\n    \"\"\"\n    # Sequential validation, slow but safe.\n    for validator in self._validators():\n        if \"insert\" in validator.config:\n            await validator(self, data, query)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validate_post_delete","title":"<code>_validate_post_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"post\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[TPrimaryKey]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules fail.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _validate_post_delete(\n    self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n) -&gt; None:\n    \"\"\"\n    Executes all \"post\" delete rules.\n\n    See `DeleteRule` for more information.\n\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n\n    Raises:\n        DeleteError: if one of the executed delete rules fail.\n    \"\"\"\n    for rule in self._delete_rules():\n        if isinstance(rule, DeleteRule) and rule.config == \"post\":\n            await rule(self, session, ids)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validate_pre_delete","title":"<code>_validate_pre_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"pre\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[TPrimaryKey]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules fail.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _validate_pre_delete(\n    self, session: AgnosticClientSession, ids: Sequence[TPrimaryKey]\n) -&gt; None:\n    \"\"\"\n    Executes all \"pre\" delete rules.\n\n    See `DeleteRule` for more information.\n\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n\n    Raises:\n        DeleteError: if one of the executed delete rules fail.\n    \"\"\"\n    for rule in self._delete_rules():\n        if isinstance(rule, DeleteRule) and rule.config == \"pre\":\n            await rule(self, session, ids)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validate_update","title":"<code>_validate_update(data, query=None)</code>  <code>async</code>","text":"<p>Validates the given piece of data for update by executing all update validators.</p> <p>See <code>Validator</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TUpdate</code> <p>The data to validate.</p> required <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If validation failed.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def _validate_update(self, data: TUpdate, query: ClauseOrMongoQuery | None = None) -&gt; None:\n    \"\"\"\n    Validates the given piece of data for update by executing all update validators.\n\n    See `Validator` for more information.\n\n    Arguments:\n        data: The data to validate.\n        query: Query that matches the documents that will be updated.\n\n    Raises:\n        ValidationError: If validation failed.\n    \"\"\"\n    # Sequential validation, slow but safe.\n    for validator in self._validators():\n        if \"update\" in validator.config:\n            await validator(self, data, query)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService._validators","title":"<code>_validators()</code>","text":"<p>Generator that yields the validators that are registered on this service in the order they are present in <code>__class__.__dict__</code>.</p> Source code in <code>motorhead/service.py</code> <pre><code>def _validators(\n    self,\n) -&gt; Generator[Validator[\"BaseService[TInsert, TUpdate, TPrimaryKey]\", TInsert | TUpdate], None, None]:\n    \"\"\"\n    Generator that yields the validators that are registered on this service\n    in the order they are present in `__class__.__dict__`.\n    \"\"\"\n    for validator in self.__class__.__dict__.values():\n        if isinstance(validator, Validator):\n            yield validator\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.aggregate","title":"<code>aggregate(pipeline, session=None, **kwargs)</code>","text":"<p>Performs an aggregation.</p> <p>For undocumented keyword arguments, see the documentation of <code>pymongo.collection.Collection.aggregate()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>Sequence[dict[str, Any]]</code> <p>The aggregation pipeline.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>motorhead/service.py</code> <pre><code>def aggregate(\n    self,\n    pipeline: Sequence[dict[str, Any]],\n    session: AgnosticClientSession | None = None,\n    **kwargs: Any,\n) -&gt; AgnosticCommandCursor:\n    \"\"\"\n    Performs an aggregation.\n\n    For undocumented keyword arguments, see the documentation of\n    `pymongo.collection.Collection.aggregate()`.\n\n    Arguments:\n        pipeline: The aggregation pipeline.\n        session: An optional session to use.\n    \"\"\"\n    return self.collection.aggregate(pipeline, session=session, **kwargs)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.count_documents","title":"<code>count_documents(query=None, *, options=None)</code>  <code>async</code>","text":"<p>Returns the number of documents that match the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>The query object.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.count_documents()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of matching documents.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def count_documents(\n    self, query: ClauseOrMongoQuery | None = None, *, options: FindOptions | None = None\n) -&gt; int:\n    \"\"\"\n    Returns the number of documents that match the given query.\n\n    Arguments:\n        query: The query object.\n        options: Query options, see the arguments of `collection.count_documents()` for details.\n\n    Returns:\n        The number of matching documents.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return await self.collection.count_documents(query, **(options or {}))\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.create","title":"<code>create(data, *, options=None)</code>  <code>async</code>","text":"<p>Inserts the given data into the collection and immediately queries and returns the created document.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <code>options</code> <code>InsertOneOptions | None</code> <p>Insert options, see the arguments of <code>collection.insert_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>ServiceException</code> <p>If the service failed to access the newly created document.</p> <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def create(self, data: TInsert, *, options: InsertOneOptions | None = None) -&gt; dict[str, Any]:\n    \"\"\"\n    Inserts the given data into the collection and immediately queries\n    and returns the created document.\n\n    Arguments:\n        data: The data to be inserted.\n        options: Insert options, see the arguments of `collection.insert_one()` for details.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        ServiceException: If the service failed to access the newly created document.\n        Exception: If the data is invalid.\n    \"\"\"\n    insert_result = await self.insert_one(data, options=options)\n    result = await self.get_by_id(insert_result.inserted_id)\n    if result is None:\n        raise ServiceException(\"Failed to query the inserted document by its ID.\")\n\n    return result\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.create_index","title":"<code>create_index(keys, *, name, unique=False, session=None, background=False, collation=None, sparse=False, **kwargs)</code>  <code>async</code>","text":"<p>Creates the specified index on collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str | Sequence[tuple[str, int | str | Mapping[str, Any]]]</code> <p>Index description.</p> required <code>name</code> <code>str</code> <p>Index name.</p> required <code>unique</code> <code>bool</code> <p>Whether to create a uniqueness constraint on the index.</p> <code>False</code> <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> <code>background</code> <code>bool</code> <p>Whether the index should be created in the background.</p> <code>False</code> <code>collation</code> <code>Collation | None</code> <p>A <code>Collation</code> instance.</p> <code>None</code> <code>sparse</code> <code>bool</code> <p>Whether to omit documents from the index that doesn't have the indexed field.</p> <code>False</code> Source code in <code>motorhead/service.py</code> <pre><code>async def create_index(\n    self,\n    keys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n    *,\n    name: str,\n    unique: bool = False,\n    session: AgnosticClientSession | None = None,\n    background: bool = False,\n    collation: Collation | None = None,\n    sparse: bool = False,\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"\n    Creates the specified index on collection of the service.\n\n    Arguments:\n        keys: Index description.\n        name: Index name.\n        unique: Whether to create a uniqueness constraint on the index.\n        session: An optional session to use.\n        background: Whether the index should be created in the background.\n        collation: A `Collation` instance.\n        sparse: Whether to omit documents from the index that doesn't have the indexed field.\n    \"\"\"\n    return await self.collection.create_index(\n        keys,\n        name=name,\n        unique=unique,\n        session=session,\n        background=background,\n        collation=collation,\n        sparse=sparse,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.create_indexes","title":"<code>create_indexes(session=None)</code>  <code>async</code>","text":"<p>Creates all declared indexes (see cls.indexes) on the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>motorhead/service.py</code> <pre><code>async def create_indexes(self, session: AgnosticClientSession | None = None) -&gt; None:\n    \"\"\"\n    Creates all declared indexes (see cls.indexes) on the collection of the service.\n\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\n    if self.indexes is None:\n        return\n\n    for name, idx in self.indexes.items():\n        await self.create_index(\n            idx.keys,\n            name=name,\n            unique=idx.unique,\n            background=idx.background,\n            collation=idx.collation,\n            sparse=idx.sparse,\n            session=session,\n            **idx.extra,\n        )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.delete_by_id","title":"<code>delete_by_id(id, *, options=None)</code>  <code>async</code>","text":"<p>Deletes the document with the given ID.</p> <p>This method is just a convenience wrapper around <code>delete_one()</code>, see that method for more details.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TPrimaryKey</code> <p>The ID of the document to delete.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_one()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def delete_by_id(\n    self,\n    id: TPrimaryKey,\n    *,\n    options: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n    \"\"\"\n    Deletes the document with the given ID.\n\n    This method is just a convenience wrapper around `delete_one()`, see that\n    method for more details.\n\n    Arguments:\n        id: The ID of the document to delete.\n        options: Delete options, see the arguments of `collection.delete_one()`.\n\n    Returns:\n        The result of the operation.\n    \"\"\"\n    return await self.delete_one({\"_id\": id}, options=options)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.delete_many","title":"<code>delete_many(query, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_many()</code> implementation of the service.</p> <p>The method enforces delete rules and executes the operation as follows:</p> <ol> <li>Enforce <code>\"deny\"</code> delete rules.</li> <li>Enforce <code>\"pre\"</code> delete rules.</li> <li>Execute the delete operation.</li> <li>Enforce <code>\"post\"</code> delete rules.</li> </ol> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query object that matches the documents that should be deleted.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_many()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def delete_many(\n    self,\n    query: ClauseOrMongoQuery | None,\n    *,\n    options: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n    \"\"\"\n    The default `delete_many()` implementation of the service.\n\n    The method enforces delete rules and executes the operation as follows:\n\n    1. Enforce `\"deny\"` delete rules.\n    2. Enforce `\"pre\"` delete rules.\n    3. Execute the delete operation.\n    4. Enforce `\"post\"` delete rules.\n\n    See `DeleteRule` for more information.\n\n    Arguments:\n        query: Query object that matches the documents that should be deleted.\n        options: Delete options, see the arguments of `collection.delete_many()`.\n\n    Returns:\n        The result of the operation.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    session_manager = self._get_session_context_manager(\n        options.get(\"session\", None) if options else None\n    )\n    async with await session_manager() as session:\n        opts: DeleteOptions = options or {}\n        opts[\"session\"] = session\n        ctxman = (\n            nullcontext\n            if (\n                session.in_transaction  # type: ignore[truthy-function]\n                or not await self.supports_transactions()\n            )\n            else session.start_transaction\n        )\n\n        ids = await self.find_ids(query, session=session) if self._has_delete_rules() else None\n\n        has_ids = ids is not None and len(ids) &gt; 0\n\n        async with ctxman():\n            if has_ids:\n                await self._validate_deny_delete(\n                    session,\n                    ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                )\n                await self._validate_pre_delete(\n                    session,\n                    ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                )\n\n            result = await self.collection.delete_many(query, **opts)\n\n            if has_ids:\n                await self._validate_post_delete(\n                    session,\n                    ids,  # type: ignore[arg-type] # can not be None if has_ids is True\n                )\n\n            return result\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.delete_one","title":"<code>delete_one(query, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_one()</code> implementation of the service.</p> <p>The method enforces delete rules and executes the operation as follows:</p> <ol> <li>Enforce <code>\"deny\"</code> delete rules.</li> <li>Enforce <code>\"pre\"</code> delete rules.</li> <li>Execute the delete operation.</li> <li>Enforce <code>\"post\"</code> delete rules.</li> </ol> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query object that matches the document that should be deleted.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_one()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def delete_one(\n    self,\n    query: ClauseOrMongoQuery | None,\n    *,\n    options: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n    \"\"\"\n    The default `delete_one()` implementation of the service.\n\n    The method enforces delete rules and executes the operation as follows:\n\n    1. Enforce `\"deny\"` delete rules.\n    2. Enforce `\"pre\"` delete rules.\n    3. Execute the delete operation.\n    4. Enforce `\"post\"` delete rules.\n\n    See `DeleteRule` for more information.\n\n    Arguments:\n        query: Query object that matches the document that should be deleted.\n        options: Delete options, see the arguments of `collection.delete_one()`.\n\n    Returns:\n        The result of the operation.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    session_manager = self._get_session_context_manager(\n        options.get(\"session\", None) if options else None\n    )\n    async with await session_manager() as session:\n        opts: DeleteOptions = options or {}\n        opts[\"session\"] = session\n        ctxman = (\n            nullcontext\n            if (\n                session.in_transaction  # type: ignore[truthy-function]\n                or not await self.supports_transactions()\n            )\n            else session.start_transaction\n        )\n\n        ids = await self.find_ids(query, session=session) if self._has_delete_rules() else None\n\n        async with ctxman():\n            if ids is not None:\n                if len(ids) &gt; 1:\n                    # Only when the service has delete rules...\n                    raise ValueError(\"Ambigous delete_one() - multiple documents match the query.\")\n\n                await self._validate_deny_delete(session, ids)\n                await self._validate_pre_delete(session, ids)\n\n            result = await self.collection.delete_one(query, **opts)\n\n            if ids is not None:\n                await self._validate_post_delete(session, ids)\n\n            return result\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.drop_index","title":"<code>drop_index(index_or_name, session=None, **kwargs)</code>  <code>async</code>","text":"<p>Drops the given index from the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>index_or_name</code> <code>str | Sequence[tuple[str, int | str | Mapping[str, Any]]]</code> <p>The index to drop.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>motorhead/service.py</code> <pre><code>async def drop_index(\n    self,\n    index_or_name: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n    session: AgnosticClientSession | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Drops the given index from the collection of the service.\n\n    Arguments:\n        index_or_name: The index to drop.\n        session: An optional session to use.\n    \"\"\"\n    return await self.collection.drop_index(\n        index_or_name,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.drop_indexes","title":"<code>drop_indexes(session=None, **kwargs)</code>  <code>async</code>","text":"<p>Drops all indexes from the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>motorhead/service.py</code> <pre><code>async def drop_indexes(self, session: AgnosticClientSession | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Drops all indexes from the collection of the service.\n\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\n    return await self.collection.drop_indexes(session, **kwargs)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.exists","title":"<code>exists(id, *, options=None)</code>  <code>async</code>","text":"<p>Returns whether the document with the given ID exists.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TPrimaryKey</code> <p>The ID of the document to check.</p> required <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.count_documents()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the document with the given ID exists.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def exists(self, id: TPrimaryKey, *, options: FindOptions | None = None) -&gt; bool:\n    \"\"\"\n    Returns whether the document with the given ID exists.\n\n    Arguments:\n        id: The ID of the document to check.\n        options: Query options, see the arguments of `collection.count_documents()` for details.\n\n    Returns:\n        Whether the document with the given ID exists.\n    \"\"\"\n    return await self.count_documents({\"_id\": id}, options=options) == 1\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.find","title":"<code>find(query=None, projection=None, *, options=None)</code>","text":"<p>The default <code>find()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>The query object.</p> <code>None</code> <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>AgnosticCursor</code> <p>An async database cursor.</p> Source code in <code>motorhead/service.py</code> <pre><code>def find(\n    self,\n    query: ClauseOrMongoQuery | None = None,\n    projection: MongoProjection | None = None,\n    *,\n    options: FindOptions | None = None,\n) -&gt; AgnosticCursor:\n    \"\"\"\n    The default `find()` implementation of the service.\n\n    Arguments:\n        query: The query object.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n\n    Returns:\n        An async database cursor.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return self.collection.find(query, projection, **(options or {}))\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.find_ids","title":"<code>find_ids(query, *, session=None)</code>  <code>async</code>","text":"<p>Returns the IDs of all documents that match the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>The query object.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional database session to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[TPrimaryKey]</code> <p>The IDs of all matching documents.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def find_ids(\n    self,\n    query: ClauseOrMongoQuery | None,\n    *,\n    session: AgnosticClientSession | None = None,\n) -&gt; list[TPrimaryKey]:\n    \"\"\"\n    Returns the IDs of all documents that match the given query.\n\n    Arguments:\n        query: The query object.\n        session: An optional database session to use.\n\n    Returns:\n        The IDs of all matching documents.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return [\n        doc[\"_id\"]\n        for doc in await self.collection.find(query, {\"_id\": True}, session=session).to_list(None)\n    ]\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.find_one","title":"<code>find_one(query=None, projection=None, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>find_one()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>The query object.</p> <code>None</code> <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A single matching document or <code>None</code> if there are no matches.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def find_one(\n    self,\n    query: ClauseOrMongoQuery | None = None,\n    projection: MongoProjection | None = None,\n    *,\n    options: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n    \"\"\"\n    The default `find_one()` implementation of the service.\n\n    Arguments:\n        query: The query object.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n\n    Returns:\n        A single matching document or `None` if there are no matches.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return await self.collection.find_one(query, projection, **(options or {}))\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.get_by_id","title":"<code>get_by_id(id, projection=None, *, options=None)</code>  <code>async</code>","text":"<p>Returns the document with the given ID if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TPrimaryKey</code> <p>The ID of the queried document.</p> required <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>The queried document if such a document exists.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def get_by_id(\n    self,\n    id: TPrimaryKey,\n    projection: MongoProjection | None = None,\n    *,\n    options: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Returns the document with the given ID if it exists.\n\n    Arguments:\n        id: The ID of the queried document.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n\n    Returns:\n        The queried document if such a document exists.\n    \"\"\"\n    return await self.find_one({\"_id\": id}, projection, options=options)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.get_objectid_fields","title":"<code>get_objectid_fields(model)</code>  <code>classmethod</code>","text":"<p>Returns the names of all <code>ObjectId</code> fields.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The model to collect <code>ObjectId</code> field</p> required Source code in <code>motorhead/service.py</code> <pre><code>@classmethod\ndef get_objectid_fields(cls, model: type[BaseModel]) -&gt; set[str]:\n    \"\"\"\n    Returns the names of all `ObjectId` fields.\n\n    Arguments:\n        model: The model to collect `ObjectId` field\n    \"\"\"\n    result: set[str] = set()\n    for name, info in model.model_fields.items():\n        if info.annotation is None:\n            continue\n\n        if args := get_args(info.annotation):\n            try:\n                if any(issubclass(a, ObjectId) for a in args):\n                    result.add(name)\n            except TypeError:\n                continue\n        elif issubclass(info.annotation, ObjectId):\n            result.add(name)\n\n    return result\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.insert_many","title":"<code>insert_many(data, *, options=None)</code>  <code>async</code>","text":"<p>Inserts all the given objects into the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[TInsert]</code> <p>The documents to be inserted.</p> required <code>options</code> <code>InsertManyOptions | None</code> <p>Insert options, see the arguments of <code>collection.insert_many()</code> for details.</p> <code>None</code> <p>Returns     The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If any of the documents is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def insert_many(\n    self, data: Iterable[TInsert], *, options: InsertManyOptions | None = None\n) -&gt; InsertManyResult:\n    \"\"\"\n    Inserts all the given objects into the collection.\n\n    Arguments:\n        data: The documents to be inserted.\n        options: Insert options, see the arguments of `collection.insert_many()` for details.\n\n    Returns\n        The result of the operation.\n\n    Raises:\n        Exception: If any of the documents is invalid.\n    \"\"\"\n    insert_data = [await self._prepare_for_insert(d) for d in data]\n    return await self.collection.insert_many(\n        insert_data,\n        **(options or {}),\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.insert_one","title":"<code>insert_one(data, *, options=None)</code>  <code>async</code>","text":"<p>Inserts the given data into the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <code>options</code> <code>InsertOneOptions | None</code> <p>Insert options, see the arguments of <code>collection.insert_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertOneResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def insert_one(\n    self, data: TInsert, *, options: InsertOneOptions | None = None\n) -&gt; InsertOneResult:\n    \"\"\"\n    Inserts the given data into the collection.\n\n    Arguments:\n        data: The data to be inserted.\n        options: Insert options, see the arguments of `collection.insert_one()` for details.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    return await self.collection.insert_one(\n        await self._prepare_for_insert(data),\n        **(options or {}),\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.list_indexes","title":"<code>list_indexes(session=None, **kwargs)</code>","text":"<p>Returns a cursor over the indexes of the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>motorhead/service.py</code> <pre><code>def list_indexes(\n    self,\n    session: AgnosticClientSession | None = None,\n    **kwargs: Any,\n) -&gt; AgnosticLatentCommandCursor:\n    \"\"\"\n    Returns a cursor over the indexes of the collection of the service.\n\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\n    return self.collection.list_indexes(session, **kwargs)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.supports_transactions","title":"<code>supports_transactions()</code>  <code>async</code>","text":"<p>Queries the database if it supports transactions or not.</p> <p>Note: transactions are only supported in replica set configuration.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def supports_transactions(self) -&gt; bool:\n    \"\"\"\n    Queries the database if it supports transactions or not.\n\n    Note: transactions are only supported in replica set configuration.\n    \"\"\"\n    if self._supports_transactions is None:\n        self._supports_transactions = \"system.replset\" in (\n            await self.client[\"local\"].list_collection_names()\n        )\n\n    return self._supports_transactions\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.update","title":"<code>update(id, changes, *, options=None)</code>  <code>async</code>","text":"<p>Updates the document with the given ID and immediately queries and returns the updated document.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TPrimaryKey</code> <p>The ID of the document to update.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateOneOptions | None</code> <p>Update options, see the arguments of <code>collection.update_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The updated document.</p> <p>Raises:</p> Type Description <code>ServiceException</code> <p>If the service failed to query the updated document.</p> <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def update(\n    self,\n    id: TPrimaryKey,\n    changes: TUpdate,\n    *,\n    options: UpdateOneOptions | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Updates the document with the given ID and immediately queries and returns\n    the updated document.\n\n    Arguments:\n        id: The ID of the document to update.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_one()` for details.\n\n    Returns:\n        The updated document.\n\n    Raises:\n        ServiceException: If the service failed to query the updated document.\n        Exception: If the data is invalid.\n    \"\"\"\n    await self.update_by_id(id, changes, options=options)\n    result = await self.get_by_id(id)\n    if result is None:\n        raise ServiceException(\"Failed to query the updated document by its ID.\")\n\n    return result\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.update_by_id","title":"<code>update_by_id(id, changes, *, options=None)</code>  <code>async</code>","text":"<p>Updates the document with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TPrimaryKey</code> <p>The ID of the document to update.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateOneOptions | None</code> <p>Update options, see the arguments of <code>collection.update_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def update_by_id(\n    self,\n    id: TPrimaryKey,\n    changes: TUpdate,\n    *,\n    options: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n    \"\"\"\n    Updates the document with the given ID.\n\n    Arguments:\n        id: The ID of the document to update.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_one()` for details.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    return await self.update_one({\"_id\": id}, changes, options=options)\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.update_many","title":"<code>update_many(query, changes, *, options=None)</code>  <code>async</code>","text":"<p>Updates the documents that match the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the documents that should be updated.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateManyOptions | None</code> <p>Update options, see the arguments of <code>collection.update_many()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def update_many(\n    self,\n    query: ClauseOrMongoQuery | None,\n    changes: TUpdate,\n    *,\n    options: UpdateManyOptions | None = None,\n) -&gt; UpdateResult:\n    \"\"\"\n    Updates the documents that match the given query.\n\n    Arguments:\n        query: Query that matches the documents that should be updated.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_many()` for details.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return await self.collection.update_many(\n        query,\n        await self._prepare_for_update(changes, query),\n        **(options or {}),\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.BaseService.update_one","title":"<code>update_one(query, changes, *, options=None)</code>  <code>async</code>","text":"<p>Updates the first document that matches the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ClauseOrMongoQuery | None</code> <p>Query that matches the document that should be updated.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateOneOptions | None</code> <p>Update options, see the arguments of <code>collection.update_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data is invalid.</p> Source code in <code>motorhead/service.py</code> <pre><code>async def update_one(\n    self,\n    query: ClauseOrMongoQuery | None,\n    changes: TUpdate,\n    *,\n    options: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n    \"\"\"\n    Updates the first document that matches the given query.\n\n    Arguments:\n        query: Query that matches the document that should be updated.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_one()` for details.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        Exception: If the data is invalid.\n    \"\"\"\n    query = {} if query is None else ensure_dict(query)\n    return await self.collection.update_one(\n        query,\n        await self._prepare_for_update(changes, query),\n        **(options or {}),\n    )\n</code></pre>"},{"location":"api/service/#motorhead.service.Service","title":"<code>Service</code>","text":"<p>               Bases: <code>BaseService[TInsert, TUpdate, ObjectId]</code></p> <p>Base service for documents with an <code>ObjectId</code> <code>_id</code>.</p> Source code in <code>motorhead/service.py</code> <pre><code>class Service(BaseService[TInsert, TUpdate, ObjectId]):\n    \"\"\"Base service for documents with an `ObjectId` `_id`.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/service/#motorhead.service.ServiceConfig","title":"<code>ServiceConfig</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Service configuration.</p> Source code in <code>motorhead/service.py</code> <pre><code>class ServiceConfig(TypedDict, total=False):\n    \"\"\"Service configuration.\"\"\"\n\n    exclude_unset_on_insert: bool\n    \"\"\"Whether to exclude fields that have not been explicitly set on the data during insert operations.\"\"\"\n</code></pre>"},{"location":"api/service/#motorhead.service.ServiceConfig.exclude_unset_on_insert","title":"<code>exclude_unset_on_insert</code>  <code>instance-attribute</code>","text":"<p>Whether to exclude fields that have not been explicitly set on the data during insert operations.</p>"},{"location":"api/service/#motorhead.service.ServiceException","title":"<code>ServiceException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for custom exceptions that can be raised by <code>Service</code>.</p> Source code in <code>motorhead/service.py</code> <pre><code>class ServiceException(Exception):\n    \"\"\"\n    Base class for custom exceptions that can be raised by `Service`.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"api/service/#motorhead.service._default_service_config","title":"<code>_default_service_config</code>","text":"<p>Default service configuration.</p> Source code in <code>motorhead/service.py</code> <pre><code>class _default_service_config:\n    \"\"\"Default service configuration.\"\"\"\n\n    exclude_unset_on_insert: ClassVar[bool] = False\n    \"\"\"See `ServiceConfig.exclude_unset_on_insert` for details.\"\"\"\n</code></pre>"},{"location":"api/service/#motorhead.service._default_service_config.exclude_unset_on_insert","title":"<code>exclude_unset_on_insert = False</code>  <code>class-attribute</code>","text":"<p>See <code>ServiceConfig.exclude_unset_on_insert</code> for details.</p>"},{"location":"api/typing/","title":"Typing","text":""},{"location":"api/typing/#motorhead.typing","title":"<code>motorhead.typing</code>","text":""},{"location":"api/typing/#motorhead.typing.MongoProjection","title":"<code>MongoProjection = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>MongoDB projection object.</p>"},{"location":"api/typing/#motorhead.typing.MongoQuery","title":"<code>MongoQuery = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>MongoDB query object.</p>"},{"location":"api/typing/#motorhead.typing.UpdateObject","title":"<code>UpdateObject = dict[str, Any] | Sequence[dict[str, Any]]</code>  <code>module-attribute</code>","text":"<p>MongoDB update object.</p>"},{"location":"api/typing/#motorhead.typing.Clause","title":"<code>Clause</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for clauses that service methods can convert to dictionaries that can be consumed by MongoDB.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class Clause(Protocol):\n    \"\"\"\n    Protocol for clauses that service methods can convert to dictionaries\n    that can be consumed by MongoDB.\n    \"\"\"\n\n    def to_mongo(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"api/typing/#motorhead.typing.ClientProvider","title":"<code>ClientProvider</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Client provider protocol for FastAPI database dependencies.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class ClientProvider(Protocol):\n    \"\"\"\n    Client provider protocol for FastAPI database dependencies.\n    \"\"\"\n\n    def __call__(self) -&gt; AgnosticClient: ...\n</code></pre>"},{"location":"api/typing/#motorhead.typing.CollationDict","title":"<code>CollationDict</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Collation definition as a dict.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class CollationDict(TypedDict, total=False):\n    \"\"\"\n    Collation definition as a dict.\n    \"\"\"\n\n    locale: str\n    caseLevel: bool | None\n    caseFirst: str | None\n    strength: int | None\n    numericOrdering: bool | None\n    alternate: str | None\n    maxVariable: str | None\n    normalization: bool | None\n    backwards: bool | None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.CollectionOptions","title":"<code>CollectionOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Collection options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class CollectionOptions(TypedDict, total=False):\n    \"\"\"\n    Collection options.\n    \"\"\"\n\n    codec_options: CodecOptions[Any] | None  # Default is None\n    read_preference: (\n        Primary | PrimaryPreferred | Secondary | SecondaryPreferred | Nearest | None\n    )  # Default  None\n    write_concern: WriteConcern | None  # Default is None\n    read_concern: ReadConcern | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.DatabaseProvider","title":"<code>DatabaseProvider</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Database provider protocol for FastAPI database dependencies.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class DatabaseProvider(Protocol):\n    \"\"\"\n    Database provider protocol for FastAPI database dependencies.\n    \"\"\"\n\n    def __call__(self) -&gt; AgnosticDatabase: ...\n</code></pre>"},{"location":"api/typing/#motorhead.typing.DeleteOptions","title":"<code>DeleteOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Delete options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class DeleteOptions(TypedDict, total=False):\n    \"\"\"\n    Delete options.\n    \"\"\"\n\n    collation: Mapping[str, Any] | Collation | None  # Default is None\n    hint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    session: AgnosticClientSession | None  # Default is None\n    let: Mapping[str, Any] | None  # Default is None\n    comment: Any | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.FindOptions","title":"<code>FindOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Find options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class FindOptions(TypedDict, total=False):\n    \"\"\"\n    Find options.\n    \"\"\"\n\n    skip: int  # Default is 0\n    limit: int  # Default is 0\n    no_cursor_timeout: bool  # Default is False\n    cursor_type: int  # Default is pymongo.cursor.CursorType.NON_TAILABLE\n    sort: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    allow_partial_results: bool  # Default is False\n    oplog_replay: bool  # Default is False\n    batch_size: int  # Default is 0\n    collation: Mapping[str, Any] | Collation | None  # Default is None\n    hint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    max_scan: int | None  # Default is None\n    max_time_ms: int | None  # Default is None\n    max: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    min: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    return_key: bool | None  # Default is None\n    show_record_id: bool | None  # Default is None\n    snapshot: bool | None  # Default is None\n    comment: Any | None  # Default is None\n    session: AgnosticClientSession | None  # Default is None\n    allow_disk_use: bool | None  # Default is None\n    let: bool | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.IndexData","title":"<code>IndexData</code>  <code>dataclass</code>","text":"<p>Index data description.</p> Source code in <code>motorhead/typing.py</code> <pre><code>@dataclass(frozen=True, kw_only=True, slots=True)\nclass IndexData:\n    \"\"\"\n    Index data description.\n    \"\"\"\n\n    keys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]]\n    unique: bool = False\n    background: bool = False\n    collation: Collation | None = None\n    sparse: bool = False\n    extra: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/typing/#motorhead.typing.InsertManyOptions","title":"<code>InsertManyOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for insert many operation.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class InsertManyOptions(TypedDict, total=False):\n    \"\"\"\n    Options for insert many operation.\n    \"\"\"\n\n    bypass_document_validation: bool  # Default is False\n    comment: Any | None  # Default is None\n    ordered: bool  # Default is True\n    session: AgnosticClientSession | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.InsertOneOptions","title":"<code>InsertOneOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Insert options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class InsertOneOptions(TypedDict, total=False):\n    \"\"\"\n    Insert options.\n    \"\"\"\n\n    bypass_document_validation: bool  # Default is False\n    session: AgnosticClientSession | None  # Default is None\n    comment: Any | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.UpdateManyOptions","title":"<code>UpdateManyOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Update-many options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class UpdateManyOptions(TypedDict, total=False):\n    \"\"\"\n    Update-many options.\n    \"\"\"\n\n    upsert: bool  # Default is False\n    array_filters: Sequence[Mapping[str, Any]] | None  # Default is None\n    bypass_document_validation: bool  # Default is None\n    collation: Mapping[str, Any] | Collation | None  # Default is None\n    hint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    session: AgnosticClientSession | None  # Default is None\n    let: Mapping[str, Any] | None  # Default is None\n    comment: Any | None  # Default is None\n</code></pre>"},{"location":"api/typing/#motorhead.typing.UpdateOneOptions","title":"<code>UpdateOneOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Update-one options.</p> Source code in <code>motorhead/typing.py</code> <pre><code>class UpdateOneOptions(TypedDict, total=False):\n    \"\"\"\n    Update-one options.\n    \"\"\"\n\n    upsert: bool  # Default is False\n    bypass_document_validation: bool  # Default is False\n    collation: Mapping[str, Any] | Collation | None  # Default is None\n    array_filters: Sequence[Mapping[str, Any]]  # Default is None\n    hint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\n    session: AgnosticClientSession | None  # Default is None\n    let: Mapping[str, Any] | None  # Default is None\n    comment: Any | None  # Default is None\n</code></pre>"},{"location":"api/validator/","title":"Validator","text":""},{"location":"api/validator/#motorhead.validator","title":"<code>motorhead.validator</code>","text":""},{"location":"api/validator/#motorhead.validator.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>BoundMethodWrapper[TOwner, [TInsertOrUpdate, ClauseOrMongoQuery | None], InsertUpdateConfig]</code></p> <p>Validator method wrapper.</p> <p>Validator methods receive an insert or update object, and execute some - potentially async - operations to make sure the inserted or updated data is valid.</p> Source code in <code>motorhead/validator.py</code> <pre><code>class Validator(\n    BoundMethodWrapper[TOwner, [TInsertOrUpdate, ClauseOrMongoQuery | None], InsertUpdateConfig]\n):\n    \"\"\"\n    Validator method wrapper.\n\n    Validator methods receive an insert or update object, and execute some - potentially\n    async - operations to make sure the inserted or updated data is valid.\n    \"\"\"\n\n    __slots__ = ()\n\n    exception = ValidationError\n</code></pre>"},{"location":"api/validator/#motorhead.validator.validator","title":"<code>validator(config='insert-update')</code>","text":"<p>Service method decorator factory that converts the decorated method into a <code>Validator</code> instance.</p> <p>Example:</p> <pre><code>class SVC(Service):\n    @validator(\"update\")\n    def check_something(self, data: InsertData | CreateData, query: ClauseOrMongoQuery | None) -&gt; None:\n        raise ValueError(\"Always fail.\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>InsertUpdateConfig</code> <p>Validatator config.</p> <code>'insert-update'</code> Source code in <code>motorhead/validator.py</code> <pre><code>def validator(\n    config: InsertUpdateConfig = \"insert-update\",\n) -&gt; Callable[\n    [Callable[[TOwner, TInsertOrUpdate, ClauseOrMongoQuery | None], Coroutine[None, None, None]]],\n    \"Validator[TOwner, TInsertOrUpdate]\",\n]:\n    \"\"\"\n    Service method decorator factory that converts the decorated method into a `Validator` instance.\n\n    Example:\n\n    ```python\n    class SVC(Service):\n        @validator(\"update\")\n        def check_something(self, data: InsertData | CreateData, query: ClauseOrMongoQuery | None) -&gt; None:\n            raise ValueError(\"Always fail.\")\n    ```\n\n    Arguments:\n        config: Validatator config.\n    \"\"\"\n\n    def decorator(\n        func: Callable[[TOwner, TInsertOrUpdate, ClauseOrMongoQuery | None], Coroutine[None, None, None]],\n        /,\n    ) -&gt; \"Validator[TOwner, TInsertOrUpdate]\":\n        return Validator(wrapped=func, config=config)\n\n    return decorator\n</code></pre>"},{"location":"api/model/deleteresultmodel/","title":"Deleteresultmodel","text":""},{"location":"api/model/deleteresultmodel/#motorhead.model.deleteresultmodel","title":"<code>motorhead.model.deleteresultmodel</code>","text":""},{"location":"api/model/deleteresultmodel/#motorhead.model.deleteresultmodel.DeleteResultModel","title":"<code>DeleteResultModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Delete result model.</p> Source code in <code>motorhead/model/deleteresultmodel.py</code> <pre><code>class DeleteResultModel(BaseModel):\n    \"\"\"\n    Delete result model.\n    \"\"\"\n\n    delete_count: int\n</code></pre>"},{"location":"api/model/document/","title":"Document","text":""},{"location":"api/model/document/#motorhead.model.document","title":"<code>motorhead.model.document</code>","text":""},{"location":"api/model/document/#motorhead.model.document.BaseDocument","title":"<code>BaseDocument</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic <code>BaseModel</code> for documents, embedded documents, and related models.</p> <p>It's just a convenience class that adds a default Pydantic <code>ConfigDict</code> with the necessary settings to enable custom types (e.g. <code>ObjectId</code>) and population by name in subclasses, so you don't have to set these settings yourself.</p> Source code in <code>motorhead/model/document.py</code> <pre><code>class BaseDocument(BaseModel):\n    \"\"\"\n    Pydantic `BaseModel` for documents, embedded documents, and related models.\n\n    It's just a convenience class that adds a default Pydantic `ConfigDict` with the\n    necessary settings to enable custom types (e.g. `ObjectId`) and population by name\n    in subclasses, so you don't have to set these settings yourself.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)\n</code></pre>"},{"location":"api/model/document/#motorhead.model.document.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>Pydantic base model for MongoDB documents.</p> <p>It exposes the <code>_id</code> attribute as <code>id</code>.</p> Source code in <code>motorhead/model/document.py</code> <pre><code>class Document(BaseDocument):\n    \"\"\"\n    Pydantic base model for MongoDB documents.\n\n    It exposes the `_id` attribute as `id`.\n    \"\"\"\n\n    id: ObjectId = Field(alias=\"_id\")\n</code></pre>"},{"location":"api/model/objectid/","title":"Objectid","text":""},{"location":"api/model/objectid/#motorhead.model.objectid","title":"<code>motorhead.model.objectid</code>","text":""},{"location":"api/model/objectid/#motorhead.model.objectid.ObjectId","title":"<code>ObjectId</code>","text":"<p>               Bases: <code>ObjectId</code></p> <p>Pydantic compatible <code>bson.objectid.ObjectId</code> field.</p> Source code in <code>motorhead/model/objectid.py</code> <pre><code>class ObjectId(BSONObjectId):\n    \"\"\"\n    Pydantic compatible `bson.objectid.ObjectId` field.\n    \"\"\"\n\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable[[Any, ValidationInfo], Any], None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: Any, _: ValidationInfo) -&gt; ObjectId:\n        if isinstance(v, bytes):\n            v = v.decode(\"utf-8\")\n        try:\n            return ObjectId(v)\n        except InvalidId as e:\n            raise ValueError(\"Invalid ObjectId\") from e\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        return core_schema.json_or_python_schema(\n            python_schema=core_schema.with_info_plain_validator_function(cls.validate),\n            json_schema=str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(lambda instance: str(instance)),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        json_schema = handler(schema)\n        json_schema.update(type=\"string\", example=\"64c571cb685348872e3a2925\")\n        return json_schema\n</code></pre>"},{"location":"api/model/utcdatetime/","title":"Utcdatetime","text":""},{"location":"api/model/utcdatetime/#motorhead.model.utcdatetime","title":"<code>motorhead.model.utcdatetime</code>","text":""},{"location":"api/model/utcdatetime/#motorhead.model.utcdatetime.UTCDatetime","title":"<code>UTCDatetime = Annotated[datetime, AfterValidator(_ensure_utc)]</code>  <code>module-attribute</code>","text":"<p>Pydantic <code>datetime</code> that accepts only naive and UTC datetime objects and replaces the timezone of naive datetimes with UTC.</p>"}]}